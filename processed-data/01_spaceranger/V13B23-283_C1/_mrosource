#
# @include "_analyzer_struct.mro"
#

#
# Copyright (c) 2022 10X Genomics, Inc. All rights reserved.
#

filetype csv;
filetype h5;
filetype html;
filetype json;
filetype pickle;
filetype binary;
#
# @include "_sc_antibody_analyzer_stages.mro"
#

#
# Copyright (c) 2021 10X Genomics, Inc. All rights reserved.
#

filetype csv;
filetype pdf;
filetype h5;
filetype json;
#
# @include "_antibody_analyzer.mro"
#

filetype pdf;
filetype csv;
filetype h5;
filetype json;
#
# @include "_cr_ana_stages.mro"
#

# Copyright 2023 10x Genomics, Inc. All rights reserved.
#
# Code generated by cr_ana.  DO NOT EDIT.
#

filetype bincode.lz4;
filetype h5;
filetype npy;
#
# @include "_batch_correction_pca.mro"
#

filetype pickle;
#
# @include "_run_kmeans.mro"
#

filetype h5;
#
# @include "_sc_rna_analyzer_stages.mro"
#

#
# Copyright (c) 2019 10X Genomics, Inc. All rights reserved.
#

filetype csv;
filetype h5;
filetype html;
filetype json;
filetype pickle;
filetype binary;
#
# @include "_antibody_qc_plots.mro"
#

#
# Copyright (c) 2023 10X Genomics, Inc. All rights reserved.
#

filetype h5;
filetype json;
#
# @include "_cr_lib_stages.mro"
#

# Copyright 2023 10x Genomics, Inc. All rights reserved.
#
# Code generated by cr_lib.  DO NOT EDIT.
#

filetype ag.vdj.bincode;
filetype ann.bincode.lz4;
filetype asf;
filetype bam;
filetype bam.bai;
filetype bam.csi;
filetype bcc.bincode;
filetype bcm.bincode;
filetype bi.bincode;
filetype bincode;
filetype bincode.lz4;
filetype blf.json;
filetype bmsf;
filetype bsc.bincode;
filetype bsf.bincode;
filetype bui;
filetype cmf.bincode;
filetype csf;
filetype csv;
filetype fbc.bincode;
filetype fprint.json;
filetype frf.bincode;
filetype h5;
filetype json;
filetype msh.bincode;
filetype msm.bincode;
filetype rpc;
filetype shard;
filetype smf.json;
filetype svg;
filetype tbcc.bincode;
filetype tps.json;
filetype umi;
filetype vwc.json;
#
# @include "_assign_tags_stages.mro"
#

#
# Copyright (c) 2021 10X Genomics, Inc. All rights reserved.
#

filetype csv;
filetype h5;
filetype json;
filetype pickle;
#
# @include "_assign_tags.mro"
#

filetype csv;
filetype h5;
filetype json;
filetype html;
filetype pickle;
#
# @include "_basic_sc_rna_counter_stages.mro"
#

filetype bam;
filetype bam.bai;
filetype csv;
filetype fastq;
filetype json;
filetype h5;
filetype pickle;
filetype bincode;
#
# @include "_common_stages.mro"
#

#
# Copyright (c) 2017 10X Genomics, Inc. All rights reserved.
#

filetype bam;
filetype bam.bai;
filetype bam.csi;
filetype csv;
filetype fastq;
filetype json;
filetype tps.json;
filetype pickle;
filetype fa;
filetype h5;
#
# @include "_deconvolve_spots.mro"
#

#
# Copyright (c) 2023 10X Genomics, Inc. All rights reserved.
#

filetype h5;
#
# @include "_run_spatial_enrichment.mro"
#

#
# Copyright (c) 2020 10X Genomics, Inc. All rights reserved.
#

filetype csv;
filetype h5;
filetype pickle;
filetype json;
#
# @include "_common_cloupe_stages.mro"
#

#
# Copyright (c) 2016 10X Genomics, Inc. All rights reserved.
#

filetype cloupe;
filetype csv;
filetype json;
filetype h5;
filetype txt;
#
# @include "_spatial_reporting_stages.mro"
#

#
# Copyright (c) 2019 10X Genomics, Inc. All rights reserved.
#

filetype csv;
filetype json;
filetype tps.json;
filetype h5;
filetype html;
filetype png;
filetype jpg;
filetype tiff;
filetype txt;
filetype parquet;
#
# @include "_spatial_stages.mro"
#

# Copyright 2023 10x Genomics, Inc. All rights reserved.
#
# Code generated by spatial.  DO NOT EDIT.
#

filetype bi.bincode;
filetype csf;
filetype csv;
filetype frf.bincode;
filetype h5;
filetype html;
filetype jpg;
filetype json;
filetype parquet;
#
# @include "_spatial_hd_binning.mro"
#

filetype h5;
filetype json;
filetype png;
filetype tiff;
#
# @include "_sc_rna_targeted_analyzer_stages.mro"
#

filetype csv;
filetype pdf;
filetype h5;
filetype json;
filetype fa;
filetype tps.json;
#
# @include "_targeted_analyzer.mro"
#

filetype csv;
filetype h5;
filetype json;
#
# @include "_spatial_cloupe_stages.mro"
#

#
# Copyright (c) 2019 10X Genomics, Inc. All rights reserved.
#

filetype csv;
filetype json;
#
# @include "_spatial_imaging_stages.mro"
#

#
# Copyright (c) 2023 10X Genomics, Inc. All rights reserved.
#

filetype jpg;
filetype png;
filetype tiff;
filetype txt;
filetype json;
filetype html;
filetype h5;
filetype csv;
filetype gpr;
filetype vlf;
#
# @include "_spatial_imaging_cs.mro"
#

filetype jpg;
filetype png;
filetype tiff;
filetype txt;
filetype json;
filetype csv;
filetype gpr;
#
# @include "_spatial_preflights.mro"
#

filetype gpr;
filetype csv;
filetype h5;
filetype tgz;
filetype vlf;

#
# @include "_analyzer_struct.mro"
#

struct AnalyzerInputs(
    h5     filtered_matrices_h5,
    h5     molecule_info,
    map[]  aggr_library_info,
    bool   no_secondary_analysis,
    csv    use_genes,
    csv    exclude_genes,
    csv    use_bcs,
    int    num_analysis_bcs,
    int    random_seed,
    int    num_pca_bcs,
    int    num_pca_genes,
    int    num_principal_comps,
    bool   chemistry_batch_correction,
    bool   is_spatial,
    bool   is_visium_hd,
    bool   is_pd,
    int    cbc_knn,
    float  cbc_alpha,
    float  cbc_sigma,
    bool   cbc_realign_panorama,
    int    max_clusters,
    int    graphclust_neighbors,
    float  neighbor_a,
    float  neighbor_b,
    float  graphclust_resolution,
    int    tsne_perplexity,
    int    tsne_input_pcs,
    int    tsne_max_dims,
    int    tsne_max_iter,
    int    tsne_stop_lying_iter,
    int    tsne_mom_switch_iter,
    float  tsne_theta,
    string umap_implementation,
    int    umap_n_neighbors,
    int    umap_input_pcs,
    int    umap_max_dims,
    float  umap_min_dist,
    string umap_metric,
    int    force_cells,
    bool   skip_multigenome_analysis,
)

struct AnalyzerOutputs(
    path analysis,
    path analysis_csv,
    h5   cloupe_matrix_h5,
    json summary,
)

#
# @include "_cr_ana_stages.mro"
#

struct PcaOutputs(
    h5   pca_h5,
    path pca_csv,
)

#
# @include "_sc_rna_analyzer_stages.mro"
#

struct PcaOutputs(
    h5   pca_h5,
    path pca_csv,
)

#
# @include "_cr_lib_stages.mro"
#

struct ReadShards(
    shard[] valid_reads,
    shard[] corrected_reads,
    shard[] invalid_reads,
)

struct WhitelistSpec(
    string name,
    file   translation_whitelist_path,
    string slide,
    string part,
)

struct BarcodeReadComponent(
    string        read_type,
    string        kind,
    int           offset,
    int           length,
    WhitelistSpec whitelist,
)

struct UmiWhitelistSpec(
    string slide,
    string part,
    string translation,
)

struct UmiReadComponent(
    string           read_type,
    int              offset,
    int              length,
    int              min_length,
    UmiWhitelistSpec whitelist,
)

struct RnaReadComponent(
    string read_type,
    int    offset,
    int    length,
    int    min_length,
)

struct ChemistryDef(
    string                 name,
    string                 description,
    string                 endedness,
    string                 strandedness,
    BarcodeReadComponent[] barcode,
    UmiReadComponent[]     umi,
    RnaReadComponent       rna,
    RnaReadComponent       rna2,
    map                    barcode_extraction,
)

struct AnnotationFiles(
    int               num_reads,
    ann.bincode.lz4[] files,
)

struct VdjFilterFlags(
    bool multiplet_filter,
    bool shared_contig_filter,
    bool umi_baseline_filter,
)

struct VdjGenInputs(
    path           reference_path,
    path           vdj_reference_path,
    int            min_contig_length,
    VdjFilterFlags filter_flags,
)

struct SampleMetrics(
    string sample,
    json   summary,
    csv    per_barcode_metrics,
)

struct SpecificityControls(
    map<string> control_for_allele,
    bool        has_mhc_allele_column,
)

struct FeatureConfig(
    string              beam_mode,
    SpecificityControls specificity_controls,
    map<string>         functional_map,
)

struct GemWellFiles(
    int[]           gem_groups,
    asf[]           alignments,
    map[]           read_chunks,
    bui[]           bc_umi_info,
    bmsf[]          per_barcode_metrics_shard,
    AnnotationFiles annotation_files,
    string          target_set_name,
    path            bam_header,
    frf.bincode     slfe_feature_reference,
)

struct FileOrBytes(
    file   file,
    string bytes,
)

struct CommonInputs(
    string sample_id,
    string sample_desc,
    string multi_config_sha,
)

struct CellCallingParam(
    float      per_gem_well,
    map<float> per_sample,
)

struct CellCalling(
    CellCallingParam recovered_cells,
    CellCallingParam force_cells,
    CellCallingParam emptydrops_minimum_umis,
    CellCallingParam global_minimum_umis,
    CellCallingParam max_mito_percent,
    json             cell_barcodes,
    string           override_mode,
    string[]         override_library_types,
    bool             disable_ab_aggregate_detection,
    bool             disable_high_occupancy_gem_detection,
)

struct BarcodeAssignments(
    json sample_barcodes,
    json non_singlet_barcodes,
    json cells_per_tag,
)

struct CountInputs(
    map[]              sample_def,
    map<string>        chemistry_specs,
    ChemistryDef       custom_chemistry_def,
    path               reference_path,
    json               gene_index,
    map[]              primers,
    CellCalling        cell_calling_config,
    float              subsample_rate,
    int                initial_reads,
    int                primer_initial_reads,
    string[]           special_genomic_regions,
    int                r1_length,
    int                r2_length,
    int                trim_polya_min_score,
    int                trim_tso_min_score,
    bool               no_secondary_analysis,
    bool               no_target_umi_filter,
    bool               filter_probes,
    csv                feature_reference,
    bool               include_exons,
    bool               include_introns,
    string             targeting_method,
    string             aligner,
    map                genetic_demux_params,
    string             throughput,
    bool               check_library_compatibility,
    bool               no_bam,
    BarcodeAssignments force_sample_barcodes,
    bool               tenx_cmos,
    float              min_assignment_confidence,
    csv[]              annotations,
    string             cas_model,
)

struct VdjInputs(
    map[]        sample_def,
    string       chemistry_spec,
    ChemistryDef custom_chemistry_def,
    map[]        primers,
    float        subsample_rate,
    int          initial_reads,
    int          primer_initial_reads,
    string[]     special_genomic_regions,
    bool         denovo,
    int          r1_length,
    int          r2_length,
    path         inner_enrichment_primers,
    string       chain_type,
    string       physical_library_id,
)

struct BasicPipelineConfig(
    bool disable_count,
    bool disable_vdj,
    bool disable_multi,
    bool disable_multi_count,
)

struct BeamAnalyzerOutputs(
    csv            antigen_specificity_scores,
    csv            antigen_assignment,
    csv            clonotype_concordance,
    csv            exact_subclonotype_concordance,
    json           specificity_summary,
    json           antigen_vdj_metrics_json,
    ag.vdj.bincode antigen_vdj_metrics_bin,
    csv            per_barcode,
)

struct VdjAnalysisConfig(
    bool per_sample,
    bool is_multi,
    bool has_no_vdj_ref,
    bool denovo,
    bool has_antigen,
)

struct GexMatrices(
    h5  filtered_matrix_h5,
    h5  raw_matrix_h5,
    csv filtered_barcodes,
)

struct VdjDemuxSampleInfo(
    string      sample_id,
    int         sample_number,
    GexMatrices gex_matrices,
    fprint.json fingerprint,
)

struct SampleMatrices(
    string sample,
    h5     filtered_matrix_h5,
    path   filtered_matrix_mex,
    h5     raw_matrix_h5,
    h5     raw_probe_bc_matrix,
    path   raw_matrix_mex,
    csv    filtered_barcodes,
    csv    aggregate_barcodes,
    csv    per_probe_metrics,
)

struct SampleMoleculeInfo(
    string sample,
    h5     h5_file,
    json   summary,
)

struct SampleBamFile(
    string  sample,
    bam     bam_file,
    bam.bai bai_index_file,
    bam.csi csi_index_file,
)

#
# @include "_assign_tags_stages.mro"
#

struct BarcodeAssignments(
    json sample_barcodes,
    json non_singlet_barcodes,
    json cells_per_tag,
)

struct AssignTagsOuts(
    BarcodeAssignments force_sample_barcodes,
    json               sample_barcodes               "Maps sample names to list of barcodes"                                                                          "sample_barcodes.json",
    json               sample_cell_barcodes,
    csv                tag_calls_per_cell            "Specifies tag assignments per cell"                                                                             "tag_calls_per_cell.csv",
    csv                tag_calls_summary             "Summarizes basic statistics about tag assignments"                                                              "tag_calls_summary",
    csv                frp_gem_barcode_overlap       "Gel-bead barcodes in common for all pairs of probe barcodes"                                                    "frp_gem_barcode_overlap.csv",
    csv                assignment_confidence_table   "Lists the posterior probabilities for tag assignments provided by JIBES model"                                  "assignment_confidence_table",
    json               cells_per_tag                 "Provides a JSON that lists, for each tag, the cells it has been assigned to"                                    "cells_per_tag.json",
    json               non_singlet_barcodes          "Provides a JSON that lists, for each non-tag assignment (blanks/unassigned), the cells it has been assigned to" "non_singlet_barcodes.json",
    csv                tag_umi_thresholds_csv        "tag UMI thresholds csv"                                                                                         "tag_umi_thresholds_csv.csv",
    csv                marginal_tag_frequencies      "marginal_tag_frequencies"                                                                                       "marginal_tag_frequencies.csv",
    csv                jibes_model_summary           "jibes_model_summary"                                                                                            "jibes_model_summary.csv",
    json               jibes_parameters              "jibes_parameters"                                                                                               "jibes_parameters.json",
    json               jibes_summary_data            "jibes_summary_data"                                                                                             "jibes_summary_data.json",
    json               tag_call_metrics              "tag_call_metrics"                                                                                               "tag_call_metrics.json",
    json               tag_umi_thresholds_json       "tag_umi_thresholds_json"                                                                                        "tag_umi_thresholds_json.json",
    json               tag_contaminant_info          "tag_contaminant_info"                                                                                           "tag_contaminant_info.json",
    pickle             tag_assigner_pickle           "tag_assigner_pickle"                                                                                            "tag_assigner_pickle.pickle",
    map<json>          sample_assignment_metrics     "Per-sample sample assignment summary metrics"                                                                   "sample_assignment_metrics.json",
    json               gem_well_inferred_throughputs "Gem well inferred throughput"                                                                                   "gem_well_inferred_throughputs.json",
    bool               multiplexing_is_not_cmo,
    bool               output_per_sample_raw_matrix,
)

#
# @include "_basic_sc_rna_counter_stages.mro"
#

struct ProbeBCDef(
    string   id,
    string[] sequence,
    int      offset,
    int      length,
)

struct CellCallingParam(
    float      per_gem_well,
    map<float> per_sample,
)

struct CellCalling(
    CellCallingParam recovered_cells,
    CellCallingParam force_cells,
    CellCallingParam emptydrops_minimum_umis,
    CellCallingParam global_minimum_umis,
    CellCallingParam max_mito_percent,
    json             cell_barcodes,
    string           override_mode,
    string[]         override_library_types,
    bool             disable_ab_aggregate_detection,
    bool             disable_high_occupancy_gem_detection,
)

#
# @include "_common_stages.mro"
#

# duplicating this here to avoid circular dependency
struct SampleSlfeOuts(
    string  sample,
    bam     bam_file,
    bam.bai bai_index_file,
    bam.csi csi_index_file,
    json    metrics_summary,
    csv     per_barcode_metrics,
    h5      molecule_info,
    h5      filtered_matrix_h5,
    path    filtered_matrix_mex,
    h5      raw_matrix_h5,
    h5      raw_probe_bc_matrix,
    path    raw_matrix_mex,
    csv     filtered_barcodes,
    csv     aggregate_barcodes,
    csv     feature_reference,
    csv     target_panel,
    csv     probe_set,
    csv     per_probe_metrics,
)

struct CellCallingParam(
    float      per_gem_well,
    map<float> per_sample,
)

#
# @include "_spatial_reporting_stages.mro"
#

struct ChemistryDef(
    string name,
)

struct SpatialFolder(
    jpg     aligned_fiducials              "Slide image annotated with fiducial alignment",
    jpg     detected_tissue_image          "Slide image annotated with detected tissue",
    json    scalefactors_json              "Scale factors for hires and lowres images and fiducial and spot diameters",
    json    tissue_transform_json          "Transform learned in tissue registration",
    png     tissue_hires_image             "Slide image scaled to 2000px in the largest dimension",
    png     tissue_lowres_image            "Slide image scaled to 600px in the largest dimension",
    tiff    cytassist_image                "RGB brightfield image generated by CytAssist instrument",
    jpg     aligned_tissue_image           "Registration image between CytAssist image and microscope image",
    csv     tissue_positions               "Slide position and tissue status of barcodes CSV",
    parquet tissue_positions_parquet       "Slide position and tissue status of barcodes PARQUET"                      "tissue_positions.parquet",
    csv     spatial_enrichment             "Per feature Moran's I CSV",
    csv     barcode_fluorescence_intensity "Fluorescence intensity at spot CSV",
)

#
# @include "_spatial_stages.mro"
#

struct WhitelistSpec(
    string name,
    file   translation_whitelist_path,
    string slide,
    string part,
)

struct BarcodeReadComponent(
    string        read_type,
    string        kind,
    int           offset,
    int           length,
    WhitelistSpec whitelist,
)

struct UmiWhitelistSpec(
    string slide,
    string part,
    string translation,
)

struct UmiReadComponent(
    string           read_type,
    int              offset,
    int              length,
    int              min_length,
    UmiWhitelistSpec whitelist,
)

struct RnaReadComponent(
    string read_type,
    int    offset,
    int    length,
    int    min_length,
)

struct ChemistryDef(
    string                 name,
    string                 description,
    string                 endedness,
    string                 strandedness,
    BarcodeReadComponent[] barcode,
    UmiReadComponent[]     umi,
    RnaReadComponent       rna,
    RnaReadComponent       rna2,
    map                    barcode_extraction,
)

struct BinLevelInfo(
    int  scale,
    bool no_secondary_analysis,
    bool disable_cloupe,
)

struct UmiRegOutsSubset(
    json transform_matrices,
    jpg  tissue_on_spots,
)

#
# @include "_spatial_hd_binning.mro"
#

# NOTE: Only png images can be displayed by default in browsers such as Chrome.
# The tiff images are downloaded and not displayed. If we need to use the log
# UMI image as the cytassist image for manual alignment in Loupe, it needs to be
# a tiff at 3k resolution. So we produce both png and tiff.
struct UmiImagesOuts(
    png  umi_image        "UMI Image (png)",
    png  log_umi_image    "Log UMI Image (png)",
    tiff log_umi_image_3k "Log UMI Image 3K (tiff)" "log_umi_image_3k.tiff",
    tiff umi_image_3k     "UMI Image 3K (tiff)"     "umi_image_3k.tiff",
)

struct BinnedOutputs(
    h5            raw_feature_bc_matrix_h5      "Unfiltered feature-barcode matrices HDF5" "raw_feature_bc_matrix.h5",
    h5            filtered_feature_bc_matrix_h5 "Filtered feature-barcode matrices HDF5"   "filtered_feature_bc_matrix.h5",
    h5            raw_probe_bc_matrix           "Raw probe barcode matrix",
    path          raw_feature_bc_matrix,
    path          filtered_feature_bc_matrix,
    path          analysis,
    path          analysis_csv,
    csv           subsampling_metrics,
    json          saturation_plots,
    SpatialFolder spatial,
    cloupe        cloupe,
    UmiImagesOuts umi_images,
)

struct BinnedOutputsCs(
    h5            raw_probe_bc_matrix           "Raw probe barcode matrix",
    path          filtered_feature_bc_matrix    "Filtered feature-barcode matrices MEX",
    h5            filtered_feature_bc_matrix_h5 "Filtered feature-barcode matrices HDF5"   "filtered_feature_bc_matrix.h5",
    path          raw_feature_bc_matrix         "Unfiltered feature-barcode matrices MEX",
    h5            raw_feature_bc_matrix_h5      "Unfiltered feature-barcode matrices HDF5" "raw_feature_bc_matrix.h5",
    path          analysis_csv                  "Secondary analysis output CSV"            "analysis",
    SpatialFolder spatial,
    cloupe        cloupe                        "Loupe Browser file",
)

#
# @include "_spatial_imaging_stages.mro"
#

struct PipelineMode(
    string product,
    string slide,
)

#
# @include "_sc_antibody_analyzer_stages.mro"
#

stage CALL_ANTIBODIES(
    in  h5   filtered_feature_counts_matrix,
    in  bool is_antibody,
    in  bool is_spatial,
    out json antibody_histograms_json,
    out json antibody_treemap_json,
    src py   "stages/feature/call_antibodies",
) split (
) using (
    volatile = strict,
)

stage SUMMARIZE_ANTIBODY_ANALYSIS(
    in  csv  aggregate_barcodes,
    in  bool is_antibody,
    out path antibody_analysis,
    src py   "stages/feature/summarize_antibody_analysis",
) using (
    mem_gb   = 4,
    volatile = strict,
)

#
# @include "_antibody_analyzer.mro"
#

pipeline _ANTIBODY_ANALYZER(
    in  h5   filtered_feature_counts_matrix,
    in  csv  aggregate_barcodes,
    in  bool is_antibody,
    in  bool is_spatial,
    out path antibody_analysis,
    out json antibody_histograms_json,
    out json antibody_treemap_json,
)
{
    # Currently makes histograms
    call CALL_ANTIBODIES(
        filtered_feature_counts_matrix = self.filtered_feature_counts_matrix,
        is_antibody = self.is_antibody,
        is_spatial  = self.is_spatial,
    )

    # Currently copies this file
    call SUMMARIZE_ANTIBODY_ANALYSIS(
        aggregate_barcodes = self.aggregate_barcodes,
        is_antibody        = self.is_antibody,
    )

    return (
        antibody_analysis        = SUMMARIZE_ANTIBODY_ANALYSIS.antibody_analysis,
        antibody_histograms_json = CALL_ANTIBODIES.antibody_histograms_json,
        antibody_treemap_json    = CALL_ANTIBODIES.antibody_treemap_json,
    )
}

#
# @include "_cr_ana_stages.mro"
#

stage RUN_DIFFERENTIAL_EXPRESSION_NG(
    in  h5          matrix_h5,
    in  h5          clustering_h5,
    in  bool        is_antibody_only,
    out h5          diffexp_h5,
    out path        diffexp_csv,
    src comp        "cr_ana martian diff_exp_stage",
) split (
    in  map[]       cluster_keys,
    out bincode.lz4 diffexp,
) using (
    volatile = strict,
)

stage RUN_GRAPH_CLUSTERING_NG(
    in  h5     matrix_h5,
    in  h5     pca_h5,
    in  int    num_neighbors,
    in  float  neighbor_a,
    in  float  neighbor_b,
    in  int    input_pcs,
    in  float  resolution,
    in  int    random_seed,
    in  int    threads,
    in  bool   parallel_clustering,
    out h5     clusters_h5,
    out path   clusters_csv,
    src comp   "cr_ana martian graph_clustering_stage",
) split (
    in  string feature_type,
) using (
    volatile = strict,
)

stage RUN_HIERARCHICAL_CLUSTERING(
    in  h5     matrix_h5,
    in  h5     graph_clusters_h5,
    out h5     clusters_h5,
    out path   clusters_csv,
    src comp   "cr_ana martian hierarchical_clustering_stage",
) split (
    in  string feature_type,
) using (
    mem_gb  = 4,
    threads = 1,
)

stage RUN_PCA_NG(
    in  h5              matrix_h5,
    in  int             num_pca_genes,
    in  int             num_principal_comps,
    in  bool            is_spatial,
    in  map<PcaOutputs> pca_map,
    out h5              pca_h5,
    out path            pca_csv,
    src comp            "cr_ana martian pca_stage",
) split (
    in  string          feature_type,
) using (
    volatile = strict,
)

stage RUN_PCA2(
    in  h5  matrix_h5,
    in  int num_pcs,
    out npy dimred_matrix,
    src comp "cr_ana martian pca2_stage",
) split (
) using (
    volatile = strict,
)

stage RUN_TSNE_NG(
    in  h5     matrix_h5,
    in  h5     pca_h5,
    in  int    random_seed,
    in  float  perplexity,
    in  int    input_pcs,
    in  int    max_dims,
    in  int    max_iter,
    in  int    stop_lying_iter,
    in  int    mom_switch_iter,
    in  float  theta,
    out h5     tsne_h5,
    out path   tsne_csv,
    src comp   "cr_ana martian tsne_stage",
) split (
    in  int    tsne_dims,
    in  string feature_type,
) using (
    volatile = strict,
)

stage RUN_UMAP(
    in  h5     matrix_h5,
    in  h5     pca_h5,
    in  int    random_seed,
    in  int    n_neighbors,
    in  int    input_pcs,
    in  int    max_dims,
    in  float  min_dist,
    in  string metric,
    in  string implementation,
    out h5     umap_h5,
    out path   umap_csv,
    src comp   "cr_ana martian umap_stage",
) split (
    in  int    umap_dims,
    in  string feature_type,
) using (
    volatile = strict,
)

#
# @include "_batch_correction_pca.mro"
#

stage PCA_PREP(
    in  h5     matrix_h5,
    in  bool   is_antibody_only,
    in  bool   is_atac,
    out float  mem_gb,
    out h5     filt_matrix,
    out string library_type,
    src py     "stages/analyzer/pca_prep",
) split (
) using (
    volatile = strict,
)

stage POST_PCA(
    in  h5     matrix_h5,
    in  h5     filt_matrix_h5,
    in  npy    dimred_matrix_npy,
    in  float  mem_gb,
    out pickle dimred_matrix,
    out pickle matrix_barcode_feature_info,
    src py     "stages/analyzer/post_pca",
) split (
) using (
    volatile = strict,
)

# Replacement for the old RUN_FBPCA which uses the PCA implemented in scan-rs
pipeline RUN_BATCH_CORRECTION_PCA(
    in  h5     matrix_h5,
    in  int    num_pcs,
    in  bool   is_antibody_only,
    in  bool   is_atac,
    out pickle dimred_matrix,
    out pickle matrix_barcode_feature_info,
    out string library_type,
)
{
    call PCA_PREP(
        matrix_h5        = self.matrix_h5,
        is_antibody_only = self.is_antibody_only,
        is_atac          = self.is_atac,
    ) using (
        volatile = true,
    )

    call RUN_PCA2(
        matrix_h5 = PCA_PREP.filt_matrix,
        num_pcs   = self.num_pcs,
    ) using (
        volatile = true,
    )

    call POST_PCA(
        matrix_h5         = self.matrix_h5,
        filt_matrix_h5    = PCA_PREP.filt_matrix,
        dimred_matrix_npy = RUN_PCA2.dimred_matrix,
        mem_gb            = PCA_PREP.mem_gb,
    ) using (
        volatile = true,
    )

    return (
        dimred_matrix               = POST_PCA.dimred_matrix,
        matrix_barcode_feature_info = POST_PCA.matrix_barcode_feature_info,
        library_type                = PCA_PREP.library_type,
    )
}

#
# @include "_run_kmeans.mro"
#

stage RUN_KMEANS(
    in  h5     matrix_h5,
    in  h5     pca_h5,
    in  int    random_seed,
    in  int    max_clusters,
    in  int    num_bcs,
    in  int    num_pcs,
    out h5     kmeans_h5,
    out path   kmeans_csv,
    src py     "stages/analyzer/run_kmeans",
) split (
    in  int    n_clusters,
    in  string library,
) using (
    volatile = strict,
)

#
# @include "_sc_rna_analyzer_stages.mro"
#

stage ANALYZER_PREFLIGHT(
    in  bool   no_secondary_analysis,
    in  h5     filtered_matrices_h5,
    in  csv    use_genes,
    in  csv    exclude_genes,
    in  csv    use_bcs,
    in  int    num_analysis_bcs,
    in  int    force_cells,
    in  int    random_seed,
    in  int    num_pca_bcs,
    in  int    num_pca_genes,
    in  int    num_principal_comps,
    in  int    cbc_knn,
    in  float  cbc_alpha,
    in  float  cbc_sigma,
    in  bool   cbc_realign_panorama,
    in  int    max_clusters,
    in  int    graphclust_neighbors,
    in  float  neighbor_a,
    in  float  neighbor_b,
    in  int    tsne_perplexity,
    in  int    tsne_input_pcs,
    in  int    tsne_max_dims,
    in  int    tsne_max_iter,
    in  int    tsne_stop_lying_iter,
    in  int    tsne_mom_switch_iter,
    in  float  tsne_theta,
    in  int    umap_n_neighbors,
    in  int    umap_input_pcs,
    in  int    umap_max_dims,
    in  float  umap_min_dist,
    in  string umap_metric,
    in  bool   chemistry_batch_correction,
    in  bool   skip_multigenome_analysis,
    out bool   skip,
    out bool   is_antibody_only,
    out bool   disable_run_pca,
    out bool   disable_correct_chemistry_batch,
    out bool   skip_multigenome_analysis,
    src py     "stages/analyzer/analyzer_preflight",
) using (
    volatile = strict,
)

stage REANALYZER_PREFLIGHT(
    in  h5 filtered_matrices_h5,
    src py "stages/analyzer/reanalyzer_preflight",
) using (
    volatile = strict,
)

stage REANALYZE_VERIFY_SAMPLE_IDS(
    in  h5    matrix_h5,
    in  map[] sample_defs,
    out map[] sample_defs,
    src py    "stages/analyzer/reanalyze_verify_sample_ids",
) using (
    volatile = strict,
)

stage PREPROCESS_MATRIX(
    in  h5   matrix_h5,
    in  int  random_seed,
    in  csv  use_genes,
    in  csv  exclude_genes,
    in  csv  use_bcs,
    in  int  num_bcs,
    in  int  force_cells,
    in  bool get_peak_matrix,
    in  bool skip,
    in  bool is_visium_hd,
    in  bool is_pd,
    in  bool is_antibody_only,
    in  bool disable_run_pca,
    in  bool disable_correct_chemistry_batch,
    in  bool skip_multigenome_analysis,
    out bool skip_antibody_analysis,
    out bool skip_antigen_analysis,
    out h5   cloupe_matrix_h5,
    out h5   preprocessed_matrix_h5,
    out bool is_multi_genome,
    out bool skip,
    out bool skip_tsne,
    out bool is_antibody_only,
    out bool disable_run_pca,
    out bool disable_correct_chemistry_batch,
    out bool skip_multigenome_analysis,
    out bool disable_hierarchical_clustering,
    src py   "stages/analyzer/preprocess_matrix",
) split (
) using (
    volatile = strict,
)

stage RUN_MULTIGENOME_ANALYSIS(
    in  h5   filtered_matrices_h5,
    in  bool is_multi_genome,
    out path multi_genome_csv,
    out path multi_genome_json,
    out json multi_genome_summary,
    src py   "stages/analyzer/run_multigenome_analysis",
) split (
) using (
    volatile = strict,
)

stage RUN_PCA(
    in  h5   matrix_h5,
    in  int  random_seed,
    in  int  num_pca_bcs,
    in  int  num_pca_genes,
    in  int  num_principal_comps,
    in  bool is_antibody_only,
    out h5   pca_h5,
    out path pca_csv,
    src py   "stages/analyzer/run_pca",
) split (
) using (
    volatile = strict,
)

stage RUN_GRAPH_CLUSTERING(
    in  h5     matrix_h5,
    in  h5     pca_h5,
    in  int    num_neighbors       "Use this many neighbors",
    in  float  neighbor_a          "Use larger of (a+b*log10(n_cells) neighbors or num_neighbors",
    in  float  neighbor_b          "Use larger of (a+b*log10(n_cells) neighbors or num_neighbors",
    in  int    num_bcs             "Use this many cell-barcodes in clustering",
    in  int    input_pcs           "Use top N PCs",
    in  int    balltree_leaf_size,
    in  string similarity_type     "Type of similarity to use (nn or snn)",
    in  int    random_seed         "Seed for random number generator",
    out h5     chunked_neighbors,
    out h5     clusters_h5,
    out path   clusters_csv,
    src py     "stages/analyzer/run_graph_clustering",
) split (
    in  pickle neighbor_index,
    in  h5     submatrix,
    in  int    row_start,
    in  int    total_rows,
    in  int    k_nearest,
    in  h5     use_bcs,
) using (
    volatile = strict,
)

stage MERGE_CLUSTERS(
    in  h5   matrix_h5,
    in  h5   pca_h5,
    in  h5   clusters_h5,
    out h5   clusters_h5,
    out path clusters_csv,
    src py   "stages/analyzer/merge_clusters",
) split (
) using (
    volatile = strict,
)

stage COMBINE_CLUSTERING(
    in  h5   kmeans_h5,
    in  path kmeans_csv,
    in  h5   graphclust_h5,
    in  path graphclust_csv,
    in  h5   hclust_h5,
    in  path hclust_csv,
    out h5   clustering_h5,
    out path clustering_csv,
    src py   "stages/analyzer/combine_clustering",
) using (
    volatile = strict,
)

stage RUN_DIFFERENTIAL_EXPRESSION(
    in  h5     matrix_h5,
    in  h5     clustering_h5,
    in  int    random_seed,
    in  int    max_clusters,
    in  bool   is_antibody_only,
    out h5     diffexp_h5,
    out path   diffexp_csv,
    src py     "stages/analyzer/run_differential_expression",
) split (
    in  string clustering_key,
) using (
    volatile = strict,
)

stage RUN_TSNE(
    in  h5     matrix_h5,
    in  h5     pca_h5,
    in  int    random_seed,
    in  int    perplexity,
    in  int    input_pcs,
    in  int    max_dims,
    in  int    max_iter,
    in  int    stop_lying_iter,
    in  int    mom_switch_iter,
    in  float  theta,
    in  bool   is_antibody_only,
    out h5     tsne_h5,
    out path   tsne_csv,
    src py     "stages/analyzer/run_tsne",
) split (
    in  int    tsne_dims,
    in  string feature_type,
) using (
    volatile = strict,
)

stage SUMMARIZE_ANALYSIS(
    in  h5    matrix_h5,
    in  h5    pca_h5,
    in  h5    clustering_h5,
    in  h5    diffexp_h5,
    in  h5    tsne_h5,
    in  h5    umap_h5,
    in  path  pca_csv,
    in  path  clustering_csv,
    in  path  diffexp_csv,
    in  path  tsne_csv,
    in  path  umap_csv,
    in  json  multi_genome_summary,
    in  path  multi_genome_csv,
    in  path  multi_genome_json,
    in  bool  is_multi_genome,
    in  bool  chemistry_batch_correction,
    in  float batch_score_before_correction,
    in  float batch_score_after_correction,
    out path  analysis,
    out path  analysis_csv,
    out json  summary,
    src py    "stages/analyzer/summarize_analysis",
) split (
) using (
    volatile = strict,
)

stage PARSE_PARAM_CSV(
    in  csv    params_csv,
    out csv    params_csv,
    out int    num_analysis_bcs,
    out int    random_seed,
    out int    num_pca_bcs,
    out int    num_pca_genes,
    out int    num_principal_comps,
    out int    cbc_knn,
    out float  cbc_alpha,
    out float  cbc_sigma,
    out bool   cbc_realign_panorama,
    out int    max_clusters,
    out int    graphclust_neighbors,
    out float  neighbor_a,
    out float  neighbor_b,
    out int    tsne_perplexity,
    out int    tsne_input_pcs,
    out int    tsne_max_dims,
    out int    tsne_max_iter,
    out int    tsne_stop_lying_iter,
    out int    tsne_mom_switch_iter,
    out float  tsne_theta,
    out int    umap_n_neighbors,
    out int    umap_input_pcs,
    out int    umap_max_dims,
    out float  umap_min_dist,
    out string umap_metric,
    src py     "stages/analyzer/parse_csv",
) using (
    volatile = strict,
)

stage SUMMARIZE_REANALYSIS(
    in  string sample_id,
    in  string sample_desc,
    in  h5     filtered_matrices,
    in  path   analysis,
    in  json   analyze_matrices_summary,
    in  json   antibody_histograms,
    in  json   antibody_treemap,
    out html   web_summary,
    out json   summary,
    out path   feature_bc_matrix_mex,
    src py     "stages/analyzer/summarize_reanalysis",
) split (
) using (
    volatile = strict,
) retain (
    summary,
)

stage CORRECT_CHEMISTRY_BATCH(
    in  pickle          dimred_matrix,
    in  pickle          matrix_barcode_feature_info,
    in  map[]           library_info,
    in  string          library_type,
    in  int             cbc_knn,
    in  float           cbc_alpha,
    in  float           cbc_sigma,
    in  bool            cbc_realign_panorama,
    out float           batch_score_before_correction,
    out float           batch_score_after_correction,
    out h5              aligned_pca_h5,
    out path            aligned_pca_csv,
    out map<PcaOutputs> aligned_pca_map,
    src py              "stages/analyzer/correct_chemistry_batch",
) split (
    in  int             batch_id,
    in  map             batch_to_bc_indices,
    in  pickle          ordered_dimred_matrix,
    in  pickle          idx_to_batch_id,
    in  bool            need_reorder_barcode,
    in  pickle          barcode_reorder_index,
    out binary          batch_nearest_neighbor,
) using (
    mem_gb   = 4,
    volatile = strict,
)

#
# @include "sc_rna_analyzer.mro"
#

pipeline SC_RNA_ANALYZER(
    in  csv                aggregate_barcodes,
    in  AnalyzerInputs     analyzer_inputs,
    out AnalyzerOutputs    common_analyzer,
    out _ANTIBODY_ANALYZER antibody_analyzer,
    out _ANTIBODY_ANALYZER antigen_analyzer,
    out h5                 clustering_h5,
)
{
    call ANALYZER_PREFLIGHT(
        * = self.analyzer_inputs,
    ) using (
        volatile = true,
    )

    call PREPROCESS_MATRIX(
        matrix_h5       = self.analyzer_inputs.filtered_matrices_h5,
        random_seed     = self.analyzer_inputs.random_seed,
        use_genes       = self.analyzer_inputs.use_genes,
        exclude_genes   = self.analyzer_inputs.exclude_genes,
        use_bcs         = self.analyzer_inputs.use_bcs,
        num_bcs         = self.analyzer_inputs.num_analysis_bcs,
        force_cells     = self.analyzer_inputs.force_cells,
        is_visium_hd    = self.analyzer_inputs.is_visium_hd,
        is_pd           = self.analyzer_inputs.is_pd,
        get_peak_matrix = false,
        *               = ANALYZER_PREFLIGHT,
    ) using (
        volatile = true,
    )

    call RUN_MULTIGENOME_ANALYSIS(
        filtered_matrices_h5 = self.analyzer_inputs.filtered_matrices_h5,
        is_multi_genome      = PREPROCESS_MATRIX.is_multi_genome,
    ) using (
        disabled = PREPROCESS_MATRIX.skip_multigenome_analysis,
        volatile = true,
    )

    call RUN_BATCH_CORRECTION_PCA(
        matrix_h5        = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        num_pcs          = self.analyzer_inputs.num_principal_comps,
        is_antibody_only = PREPROCESS_MATRIX.is_antibody_only,
        is_atac          = false,
    ) using (
        disabled = PREPROCESS_MATRIX.disable_correct_chemistry_batch,
    )

    call CORRECT_CHEMISTRY_BATCH(
        dimred_matrix               = RUN_BATCH_CORRECTION_PCA.dimred_matrix,
        matrix_barcode_feature_info = RUN_BATCH_CORRECTION_PCA.matrix_barcode_feature_info,
        library_info                = self.analyzer_inputs.aggr_library_info,
        library_type                = RUN_BATCH_CORRECTION_PCA.library_type,
        cbc_knn                     = self.analyzer_inputs.cbc_knn,
        cbc_alpha                   = self.analyzer_inputs.cbc_alpha,
        cbc_sigma                   = self.analyzer_inputs.cbc_sigma,
        cbc_realign_panorama        = self.analyzer_inputs.cbc_realign_panorama,
    ) using (
        disabled = PREPROCESS_MATRIX.disable_correct_chemistry_batch,
        volatile = true,
    )

    call RUN_PCA_NG as RUN_PCA(
        matrix_h5           = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        num_pca_genes       = self.analyzer_inputs.num_pca_genes,
        num_principal_comps = self.analyzer_inputs.num_principal_comps,
        is_spatial          = self.analyzer_inputs.is_spatial,
        pca_map             = CORRECT_CHEMISTRY_BATCH.aligned_pca_map,
    ) using (
        disabled = PREPROCESS_MATRIX.disable_run_pca,
        volatile = true,
    )

    call RUN_KMEANS(
        matrix_h5    = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        pca_h5       = RUN_PCA.pca_h5,
        random_seed  = self.analyzer_inputs.random_seed,
        max_clusters = self.analyzer_inputs.max_clusters,
        num_bcs      = null,
        num_pcs      = null,
    ) using (
        disabled = PREPROCESS_MATRIX.skip,
        volatile = true,
    )

    call RUN_GRAPH_CLUSTERING_NG as RUN_GRAPH_CLUSTERING(
        matrix_h5           = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        pca_h5              = RUN_PCA.pca_h5,
        num_neighbors       = self.analyzer_inputs.graphclust_neighbors,
        neighbor_a          = self.analyzer_inputs.neighbor_a,
        neighbor_b          = self.analyzer_inputs.neighbor_b,
        input_pcs           = null,
        resolution          = self.analyzer_inputs.graphclust_resolution,
        random_seed         = self.analyzer_inputs.random_seed,
        threads             = 4,
        parallel_clustering = false,
    ) using (
        disabled = PREPROCESS_MATRIX.skip,
        volatile = true,
    )

    call RUN_HIERARCHICAL_CLUSTERING(
        matrix_h5         = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        graph_clusters_h5 = RUN_GRAPH_CLUSTERING.clusters_h5,
    ) using (
        disabled = PREPROCESS_MATRIX.disable_hierarchical_clustering,
        volatile = true,
    )

    call COMBINE_CLUSTERING(
        kmeans_h5      = RUN_KMEANS.kmeans_h5,
        kmeans_csv     = RUN_KMEANS.kmeans_csv,
        graphclust_h5  = RUN_GRAPH_CLUSTERING.clusters_h5,
        graphclust_csv = RUN_GRAPH_CLUSTERING.clusters_csv,
        hclust_h5      = RUN_HIERARCHICAL_CLUSTERING.clusters_h5,
        hclust_csv     = RUN_HIERARCHICAL_CLUSTERING.clusters_csv,
    ) using (
        disabled = PREPROCESS_MATRIX.skip,
        volatile = true,
    )

    call RUN_DIFFERENTIAL_EXPRESSION_NG as RUN_DIFFERENTIAL_EXPRESSION(
        matrix_h5        = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        clustering_h5    = COMBINE_CLUSTERING.clustering_h5,
        is_antibody_only = PREPROCESS_MATRIX.is_antibody_only,
    ) using (
        disabled = PREPROCESS_MATRIX.skip,
        volatile = true,
    )

    call RUN_TSNE_NG as RUN_TSNE(
        matrix_h5       = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        pca_h5          = RUN_PCA.pca_h5,
        random_seed     = self.analyzer_inputs.random_seed,
        perplexity      = self.analyzer_inputs.tsne_perplexity,
        input_pcs       = self.analyzer_inputs.tsne_input_pcs,
        max_dims        = self.analyzer_inputs.tsne_max_dims,
        max_iter        = self.analyzer_inputs.tsne_max_iter,
        stop_lying_iter = self.analyzer_inputs.tsne_stop_lying_iter,
        mom_switch_iter = self.analyzer_inputs.tsne_mom_switch_iter,
        theta           = self.analyzer_inputs.tsne_theta,
    ) using (
        disabled = PREPROCESS_MATRIX.skip_tsne,
        volatile = true,
    )

    call RUN_UMAP(
        matrix_h5      = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        pca_h5         = RUN_PCA.pca_h5,
        implementation = self.analyzer_inputs.umap_implementation,
        random_seed    = self.analyzer_inputs.random_seed,
        n_neighbors    = self.analyzer_inputs.umap_n_neighbors,
        input_pcs      = self.analyzer_inputs.umap_input_pcs,
        max_dims       = self.analyzer_inputs.umap_max_dims,
        min_dist       = self.analyzer_inputs.umap_min_dist,
        metric         = self.analyzer_inputs.umap_metric,
    ) using (
        disabled = PREPROCESS_MATRIX.skip,
        volatile = true,
    )

    call SUMMARIZE_ANALYSIS(
        matrix_h5                     = PREPROCESS_MATRIX.preprocessed_matrix_h5,
        pca_h5                        = RUN_PCA.pca_h5,
        clustering_h5                 = COMBINE_CLUSTERING.clustering_h5,
        diffexp_h5                    = RUN_DIFFERENTIAL_EXPRESSION.diffexp_h5,
        tsne_h5                       = RUN_TSNE.tsne_h5,
        umap_h5                       = RUN_UMAP.umap_h5,
        pca_csv                       = RUN_PCA.pca_csv,
        clustering_csv                = COMBINE_CLUSTERING.clustering_csv,
        diffexp_csv                   = RUN_DIFFERENTIAL_EXPRESSION.diffexp_csv,
        tsne_csv                      = RUN_TSNE.tsne_csv,
        umap_csv                      = RUN_UMAP.umap_csv,
        multi_genome_summary          = RUN_MULTIGENOME_ANALYSIS.multi_genome_summary,
        multi_genome_csv              = RUN_MULTIGENOME_ANALYSIS.multi_genome_csv,
        multi_genome_json             = RUN_MULTIGENOME_ANALYSIS.multi_genome_json,
        is_multi_genome               = PREPROCESS_MATRIX.is_multi_genome,
        chemistry_batch_correction    = self.analyzer_inputs.chemistry_batch_correction,
        batch_score_before_correction = CORRECT_CHEMISTRY_BATCH.batch_score_before_correction,
        batch_score_after_correction  = CORRECT_CHEMISTRY_BATCH.batch_score_after_correction,
    ) using (
        disabled = PREPROCESS_MATRIX.skip,
    )

    # Note this stage uses the original and the the preprocessed matrix.
    call _ANTIBODY_ANALYZER(
        filtered_feature_counts_matrix = self.analyzer_inputs.filtered_matrices_h5,
        aggregate_barcodes = self.aggregate_barcodes,
        is_antibody        = true,
        is_spatial         = self.analyzer_inputs.is_spatial,
    ) using (
        disabled = PREPROCESS_MATRIX.skip_antibody_analysis,
    )

    call _ANTIBODY_ANALYZER as _ANTIGEN_ANALYZER(
        filtered_feature_counts_matrix = self.analyzer_inputs.filtered_matrices_h5,
        aggregate_barcodes = self.aggregate_barcodes,
        is_antibody        = false,
        is_spatial         = self.analyzer_inputs.is_spatial,
    ) using (
        disabled = PREPROCESS_MATRIX.skip_antigen_analysis,
    )

    return (
        antibody_analyzer = _ANTIBODY_ANALYZER,
        antigen_analyzer  = _ANTIGEN_ANALYZER,
        clustering_h5     = COMBINE_CLUSTERING.clustering_h5,
        common_analyzer   = {
            analysis:         SUMMARIZE_ANALYSIS.analysis,
            analysis_csv:     SUMMARIZE_ANALYSIS.analysis_csv,
            cloupe_matrix_h5: PREPROCESS_MATRIX.cloupe_matrix_h5,
            summary:          SUMMARIZE_ANALYSIS.summary,
        },
    )
}

#
# @include "_antibody_qc_plots.mro"
#

stage ANTIBODY_QC_PLOTS(
    in  h5   filtered_matrix,
    in  h5   raw_matrix,
    out json raw_normalized_heatmap,
    out json isotype_scatter,
    out json gex_fbc_correlation_heatmap,
    out json ab_qc_summary,
    src py   "stages/spatial/antibody_qc_plots",
) split (
) using (
    volatile = strict,
)

#
# @include "_cr_lib_stages.mro"
#

stage ALIGN_AND_COUNT(
    in  int               gem_well,
    in  map[]             read_chunks,
    in  path              reference_path,
    in  ReadShards        read_shards,
    in  fbc.bincode       feature_counts,
    in  frf.bincode       feature_reference,
    in  csv               target_set,
    in  map<ChemistryDef> chemistry_defs,
    in  string            aligner,
    in  bool              include_exons,
    in  bool              include_introns,
    in  bool              is_pd,
    in  bool              no_bam,
    in  int               targeted_umi_min_read_count,
    in  int               transcriptome_min_score,
    in  int               trim_polya_min_score,
    in  int               trim_tso_min_score,
    in  tbcc.bincode      total_barcode_counts,
    in  blf.json          barcode_subset,
    in  float             chevron_correction_factor,
    in  json              chevron_affected_barcodes,
    out csf[]             counts_bc_order,
    out csf[]             probe_barcode_counts,
    out bui[]             bc_umi_info,
    out asf[]             pos_sorted,
    out path              bam_header,
    out csv               barcode_summary,
    out AnnotationFiles   annotation_files,
    out bmsf[]            per_barcode_metrics,
    out json              summary,
    out bool              no_star_alignments,
    src comp              "cr_lib martian align_and_count",
) split (
    in  map               range,
    in  float             read_ann_subsample_rate,
    out csf               counts_bc_order_shard,
    out csf               probe_barcode_counts_shard,
    out bui               bc_umi_info_shard,
    out asf               pos_sorted_shard,
    out bsf.bincode       barcode_summary_shard,
    out bmsf              metrics_shard,
) using (
    mem_gb   = 4,
    volatile = strict,
)

stage BARCODE_CORRECTION(
    in  int               gem_well,
    in  shard[]           invalid_uncorrected,
    in  map<ChemistryDef> chemistry_defs,
    in  bsc.bincode       barcode_segment_counts,
    in  bcc.bincode       barcode_counts,
    in  bcm.bincode       valid_read_metrics,
    in  string[]          libraries_to_translate,
    in  cmf.bincode       correction_map,
    in  int               min_reads_to_report_bc,
    out shard[]           valid_corrected,
    out shard[]           invalid,
    out json              summary,
    out bcc.bincode       corrected_barcode_counts,
    out tbcc.bincode      total_barcode_counts,
    src comp              "cr_lib martian barcode_correction",
) split (
    in  map               range,
    out shard             valid_shard,
    out shard             invalid_shard,
    out bcm.bincode       chunk_summary,
) using (
    mem_gb   = 4,
    volatile = strict,
)

stage BUILD_PER_SAMPLE_VDJ_WS_CONTENTS(
    in  json          lib_level_metrics,
    in  map<json>     per_sample_metrics,
    in  string        receptor,
    in  string        physical_library_id,
    in  VdjGenInputs  vdj_gen_inputs,
    in  smf.json      sequencing_metrics,
    in  map<json>     vdj_ws_json,
    in  map<json>     filter_metrics,
    out map<vwc.json> vdj_ws_contents,
    src comp          "cr_lib martian build_per_sample_vdj_ws_contents",
) split (
    in  string        sample,
    out vwc.json      vdj_ws,
) using (
    volatile = strict,
)

stage CALL_TAGS_OH(
    in  map<ChemistryDef> chemistry_defs,
    in  h5                raw_feature_bc_matrix,
    out json              barcodes_per_tag,
    out json              summary,
    src comp              "cr_lib martian call_tags_oh",
) using (
    mem_gb   = 8,
    volatile = strict,
)

stage CALL_TAGS_RTL(
    in  map<ChemistryDef> chemistry_defs,
    in  h5                raw_feature_bc_matrix,
    in  h5                filtered_feature_bc_matrix,
    in  json              multi_graph,
    out json              barcodes_per_tag,
    out csv               frp_gem_barcode_overlap,
    out json              summary,
    src comp              "cr_lib martian call_tags_rtl",
) split (
) using (
    volatile = strict,
)

stage CHECK_BARCODES_COMPATIBILITY(
    in  map<ChemistryDef> chemistry_defs,
    in  map[]             sample_def,
    in  bool              check_library_compatibility,
    out string[]          libraries_to_translate,
    src comp              "cr_lib martian check_barcodes_compatibility",
) using (
    mem_gb = 2,
)

stage CHECK_BARCODES_COMPATIBILITY_VDJ(
    in  ChemistryDef      vdj_chemistry_def,
    in  map[]             vdj_sample_def,
    in  map<ChemistryDef> count_chemistry_defs,
    in  map[]             gex_sample_def,
    in  bool              check_library_compatibility,
    out float             similarity_score,
    src comp              "cr_lib martian check_barcodes_compatibility_vdj",
)

stage CHECK_SINGLE_BEAM_MODE(
    in  string[] beam_modes,
    out string   beam_mode,
    src comp     "cr_lib martian check_single_beam_mode",
) using (
    volatile = strict,
)

stage COLLATE_METRICS(
    in  bmsf[]          per_barcode_metrics,
    in  path            reference_path,
    in  frf.bincode     feature_reference,
    in  csv             filtered_barcodes,
    in  csv             aggregate_barcodes,
    in  json            sample_barcodes,
    out json            summary,
    out csv             per_barcode_metrics,
    out SampleMetrics[] multi_metrics,
    src comp            "cr_lib martian collate_metrics",
) split (
    in  string          sample,
) using (
    volatile = strict,
)

stage COLLATE_PROBE_METRICS(
    in  csf[]      probe_barcode_counts,
    in  path       reference_path,
    in  csv        probe_set,
    in  csv        filtered_barcodes,
    in  string     probe_set_name,
    in  bi.bincode barcode_index_path,
    out csv        per_probe_metrics,
    out h5         raw_probe_bc_matrix,
    out json       estimated_gdna_metrics,
    src comp       "cr_lib martian collate_probe_metrics",
) using (
    mem_gb   = 8,
    volatile = strict,
)

stage COMPUTE_ANTIGEN_VDJ_METRICS(
    in  json           vdj_cell_barcodes,
    in  bmsf[]         per_barcode_count_metrics,
    out json           metrics_json,
    out ag.vdj.bincode metrics_bin,
    src comp           "cr_lib martian compute_antigen_vdj_metrics",
) using (
    mem_gb   = 4,
    volatile = strict,
)

stage COPY_CHEMISTRY_SPEC(
    in  map[]       sample_defs,
    in  string      chemistry_spec,
    out map<string> chemistry_specs,
    src comp        "cr_lib martian copy_chemistry_spec",
) using (
    volatile = strict,
)

stage CREATE_MULTI_GRAPH(
    in  string sample_id,
    in  string sample_desc,
    in  csv    multi_config,
    in  json   detected_probe_barcode_pairing,
    out json   multi_graph,
    src comp   "cr_lib martian create_multi_graph",
) using (
    volatile = strict,
)

stage DEMUX_PROBE_BC_MATRIX(
    in  csf[]    probe_barcode_counts,
    in  path     reference_path,
    in  csv      probe_set,
    in  string   probe_set_name,
    in  json     sample_barcodes,
    in  json     sample_cell_barcodes,
    out map<h5>  sample_raw_probe_bc_matrices,
    out map<csv> samples_per_probe_metrics,
    src comp     "cr_lib martian demux_probe_bc_matrix",
) split (
    in  string   sample_name,
    out csv      sample_per_probe_metrics,
    out h5       sample_raw_probe_bc_matrix,
) using (
    volatile = strict,
)

stage DETECT_CHEMISTRY(
    in  map[]             sample_def,
    in  path              reference_path,
    in  csv               feature_reference,
    in  map<string>       chemistry_specs,
    in  string[]          allowed_chems,
    in  int               r1_length,
    in  int               r2_length,
    in  csv               multi_config,
    in  bool              is_pd,
    in  ChemistryDef      custom_chemistry_def,
    in  FeatureConfig     feature_config,
    out map<ChemistryDef> chemistry_defs,
    out bool              is_antibody_only,
    out csv               probe_barcode_overlap,
    out json              detected_probe_barcode_pairing,
    src comp              "cr_lib martian detect_chemistry",
) using (
    mem_gb   = 20,
    volatile = strict,
) retain (
    detected_probe_barcode_pairing,
    probe_barcode_overlap,
)

stage DETECT_VDJ_RECEPTOR(
    in  string        force_receptor,
    in  path          vdj_reference_path,
    in  csv           feature_reference,
    in  map[]         gex_sample_def,
    in  map[]         vdj_sample_def,
    in  bool          is_multi,
    in  FeatureConfig feature_config,
    out string        receptor,
    out string        beam_mode,
    src comp          "cr_lib martian detect_vdj_receptor",
) using (
    volatile = strict,
)

stage EXTRACT_SINGLE_CHEMISTRY(
    in  map<ChemistryDef> chemistry_defs,
    in  string            library_to_extract,
    out ChemistryDef      chemistry_def,
    src comp              "cr_lib martian extract_single_chemistry",
) using (
    volatile = strict,
)

stage GET_CHEMISTRY_DEF(
    in  string       chemistry_name,
    in  ChemistryDef custom_chemistry_def,
    out ChemistryDef chemistry_def,
    src comp         "cr_lib martian get_chemistry_def",
) using (
    volatile = strict,
)

stage GET_GDNA_METRICS(
    in  h5   molecule_info,
    in  path reference_path,
    in  csv  probe_set,
    out json summary,
    out json gdna_plot_sufficient_stats,
    src comp "cr_lib martian get_gdna_metrics",
) using (
    mem_gb   = 4,
    volatile = strict,
)

stage LOGIC_NOT(
    in  bool boolean,
    out bool not_boolean,
    src comp "cr_lib martian logic_not",
) using (
    volatile = strict,
)

stage MAKE_CORRECTION_MAP(
    in  map<ChemistryDef> chemistry_defs,
    in  bsc.bincode       barcode_segment_counts,
    out cmf.bincode       correction_map,
    src comp              "cr_lib martian make_correction_map",
) split (
) using (
    volatile = strict,
)

stage MAKE_SHARD(
    in  map<ChemistryDef> chemistry_defs,
    in  int               gem_well,
    in  map[]             read_chunks,
    in  int               r1_length,
    in  int               r2_length,
    in  float             subsample_rate,
    in  int               initial_read_pairs,
    in  path              reference_path,
    in  csv               feature_reference_path,
    in  csv               target_features,
    in  csv               target_set,
    in  string            target_set_name,
    in  string[]          libraries_to_translate,
    in  FeatureConfig     feature_config,
    out shard[]           valid,
    out shard[]           invalid,
    out bcc.bincode       barcode_counts,
    out bsc.bincode       barcode_segment_counts,
    out fbc.bincode       feature_counts,
    out json              summary,
    out int               total_read_pairs,
    out frf.bincode       feature_reference,
    out bcm.bincode       bc_correct_summary,
    out smf.json          sequencing_metrics,
    src comp              "cr_lib martian make_shard",
) split (
    in  int               chunk_id,
    in  frf.bincode       feature_reference,
    out shard             valid_shard,
    out shard             invalid_shard,
    out rpc               read_prefix_counts,
    out umi               umi_counts,
    out msm.bincode       chunk_summary,
    out msh.bincode       chunk_hist,
) using (
    volatile = strict,
)

stage MERGE_GEM_WELL_FILES(
    in  GemWellFiles[] unmerged_gem_well_files,
    out GemWellFiles   merged_gem_well_files,
    src comp           "cr_lib martian merge_gem_well_files",
) using (
    volatile = strict,
)

stage MERGE_METRICS(
    in  json[] summaries,
    out json   summary,
    src comp   "cr_lib martian merge_metrics",
) using (
    volatile = strict,
)

stage MULTI_PREFLIGHT(
    in  FileOrBytes config,
    in  bool        is_pd,
    src comp        "cr_lib martian multi_preflight",
) using (
    volatile = strict,
)

stage MULTI_SETUP_CHUNKS(
    in  string            sample_id,
    in  map[]             sample_def,
    in  map<ChemistryDef> chemistry_defs,
    in  string            default_library_type,
    out map[]             chunks,
    out string            barcode_whitelist,
    out string            visium_hd_slide_name,
    src comp              "cr_lib martian multi_setup_chunks",
)

stage PARSE_MULTI_CONFIG(
    in  string              sample_id,
    in  string              sample_desc,
    in  FileOrBytes         config,
    in  string              config_hash,
    in  map                 params,
    in  bool                is_pd,
    out CommonInputs        common_input,
    out CountInputs         count_input,
    out VdjInputs[]         vdj_inputs,
    out VdjGenInputs        vdj_gen_inputs,
    out BasicPipelineConfig basic_config,
    out csv                 config_file,
    out FeatureConfig       feature_config,
    out csv                 feature_ref,
    out json                cell_barcodes,
    out json                sample_barcodes,
    out json                non_singlet_barcodes,
    out json                cells_per_tag,
    out csv                 barcode_sample_assignments,
    src comp                "cr_lib martian parse_multi_config",
) using (
    mem_gb   = 6,
    volatile = strict,
) retain (
    barcode_sample_assignments,
    cell_barcodes,
    cells_per_tag,
    feature_ref,
    non_singlet_barcodes,
    sample_barcodes,
)

stage PICK_BEAM_ANALYZER(
    in  map<BeamAnalyzerOutputs> vdj_t,
    in  map<BeamAnalyzerOutputs> vdj_t_gd,
    in  map<BeamAnalyzerOutputs> vdj_b,
    out map<BeamAnalyzerOutputs> output,
    src comp                     "cr_lib martian pick_beam_analyzer",
) using (
    volatile = strict,
)

stage RUST_BRIDGE(
    in  map<ChemistryDef> chemistry_defs,
    in  int               gem_well,
    in  shard[]           valid_uncorrected,
    in  shard[]           valid_corrected,
    in  bcc.bincode       raw_barcode_counts,
    in  bcc.bincode       corrected_barcode_counts,
    out bincode.lz4[]     bc_sorted_rna_reads,
    out int[]             gem_groups,
    out json[]            barcodes,
    out json              raw_barcode_counts_json,
    out json              corrected_barcode_counts_json,
    out json              summary,
    out int               n50_n50_rpu,
    out int               processed_read_pairs,
    src comp              "cr_lib martian rust_bridge",
) split (
    in  map               range,
    in  shard[]           valid_shards,
    out bincode.lz4       chunk_bc_sorted_rna_reads,
    out json              barcodes_shard,
    out bincode           n50s_shard,
) using (
    mem_gb = 4,
)

stage SET_TARGETED_UMI_FILTER(
    in  bui[]       bc_umi_info,
    in  frf.bincode feature_reference,
    out int         umi_read_count_threshold,
    out json        summary,
    src comp        "cr_lib martian set_targeted_umi_filter",
) using (
    mem_gb   = 8,
    volatile = strict,
)

stage SETUP_VDJ_ANALYSIS(
    in  string             receptor,
    in  VdjAnalysisConfig  vdj_config,
    in  VdjDemuxSampleInfo demux_sample_info,
    in  GexMatrices        lib_level_gex,
    out string             receptor,
    out bool               disable_cell_calling,
    out bool               disable_clonotyping,
    out bool               disable_beam,
    out string             beam_mode,
    out h5                 filtered_matrix_h5,
    out h5                 raw_matrix_h5,
    out csv                filtered_barcodes,
    src comp               "cr_lib martian setup_vdj_analysis",
)

stage SETUP_VDJ_DEMUX(
    in  SampleMatrices[]        multi_matrices,
    in  json                    multi_graph,
    out bool                    is_multi,
    out bool                    is_not_multi,
    out bool                    has_antigen,
    out map<VdjDemuxSampleInfo> per_sample_info,
    src comp                    "cr_lib martian setup_vdj_demux",
)

stage SUBSAMPLE_BARCODES(
    in  bcc.bincode corrected_barcode_counts,
    out blf.json    barcode_subset,
    src comp        "cr_lib martian subsample_barcodes",
) using (
    mem_gb   = 4,
    volatile = strict,
)

stage WRITE_BARCODE_INDEX(
    in  bcc.bincode barcode_counts,
    in  json        barcodes_under_tissue,
    out bi.bincode  barcode_index,
    src comp        "cr_lib martian write_barcode_index",
) using (
    mem_gb   = 6,
    volatile = strict,
)

stage WRITE_BARCODE_SUMMARY(
    in  bmsf[]      per_barcode_metrics,
    in  frf.bincode feature_reference,
    in  bi.bincode  barcode_index,
    out h5          barcode_summary,
    src comp        "cr_lib martian write_barcode_summary",
) using (
    mem_gb   = 7,
    volatile = strict,
)

stage WRITE_GENE_INDEX(
    in  path reference_path,
    out json gene_index,
    src comp "cr_lib martian write_gene_index",
) using (
    mem_gb   = 6,
    volatile = strict,
)

stage WRITE_H5_MATRIX(
    in  int               gem_well,
    in  csf[]             counts,
    in  frf.bincode       feature_reference,
    in  map<ChemistryDef> chemistry_defs,
    in  string            sample_id,
    in  bi.bincode        barcode_index,
    out h5                matrix,
    src comp              "cr_lib martian write_h5_matrix",
) using (
    mem_gb   = 7,
    volatile = strict,
)

stage WRITE_MATRIX_MARKET(
    in  csf[]       counts,
    in  frf.bincode feature_reference,
    in  bi.bincode  barcode_index,
    out path        feature_bc_matrix,
    src comp        "cr_lib martian write_matrix_market",
) using (
    mem_gb   = 7,
    volatile = strict,
)

stage WRITE_MOLECULE_INFO(
    in  map<ChemistryDef>    chemistry_defs,
    in  int                  gem_well,
    in  bui[]                counts_bc_order,
    in  path                 reference_path,
    in  map[]                read_chunks,
    in  frf.bincode          feature_reference,
    in  csv                  filtered_barcodes,
    in  csv                  per_probe_metrics,
    in  tps.json             target_panel_summary,
    in  json                 matrix_computer_summary,
    in  CellCallingParam     recovered_cells,
    in  CellCallingParam     force_cells,
    in  bool                 include_introns,
    in  bool                 filter_probes,
    in  string               multi_config_sha,
    in  json                 sample_barcodes,
    in  SampleMetrics[]      per_sample_metrics,
    in  bi.bincode           barcode_index,
    in  string               slide_serial_capture_area,
    out SampleMoleculeInfo   single_mol_info,
    out SampleMoleculeInfo[] multi_mol_info,
    src comp                 "cr_lib martian write_molecule_info",
) split (
) using (
    volatile = strict,
)

stage WRITE_MULTI_WEB_SUMMARY_JSON(
    in  map<json>           per_sample_metrics,
    in  json                library_metrics,
    in  smf.json            sequencing_metrics,
    in  csv                 multi_config,
    in  json                multi_graph,
    in  svg                 multi_graph_svg,
    in  CommonInputs        common_inputs,
    in  CountInputs         count_inputs,
    in  json                tag_contaminant_info,
    in  map<json>           sample_tsne_plots,
    in  map<json>           sample_barcode_rank_plots,
    in  map<json>           sample_treemap_plots,
    in  json                barcode_rank_plots,
    in  json                jibes_biplot_histogram,
    in  json                antibody_histograms,
    in  map<json>           sample_antibody_histograms,
    in  json                antigen_histograms,
    in  csv                 targeted_per_feature_metrics,
    in  json                cmo_tsne_plot,
    in  map<vwc.json>       vdj_t_contents,
    in  map<vwc.json>       vdj_t_gd_contents,
    in  map<vwc.json>       vdj_b_contents,
    in  string              target_set_name,
    in  map<ag.vdj.bincode> antigen_vdj_metrics,
    in  map<csv>            antigen_specificity,
    in  FeatureConfig       feature_config,
    in  map<ChemistryDef>   chemistry_defs,
    in  json                detected_probe_barcode_pairing,
    in  bool                no_preflight,
    out map<json>           web_summary_json,
    out map<csv>            metrics_summary_csv,
    out map<json>           metrics_summary_json,
    src comp                "cr_lib martian write_multi_web_summary_json",
) using (
    mem_gb   = 5,
    volatile = strict,
) retain (
    metrics_summary_json,
    web_summary_json,
)

stage WRITE_POS_BAM(
    in  path            bam_header,
    in  asf[]           alignments,
    in  map[]           read_chunks,
    in  string          target_set_name,
    in  json            sample_barcodes,
    in  string          slide_serial_capture_area,
    out SampleBamFile   pos_sorted_bam,
    out SampleBamFile[] multi_pos_sorted_bam,
    src comp            "cr_lib martian write_pos_bam",
) split (
    in  map             range,
    in  bool            write_header,
    out map<bam>        sample_pos_sorted_bam_chunks,
) using (
    volatile = strict,
)

#
# @include "_assign_tags_stages.mro"
#

stage MULTIPLEXING_METHOD(
    in  json multi_graph,
    out bool multiplexing_is_not_rtl,
    out bool multiplexing_is_not_cmo,
    out bool multiplexing_is_not_oh,
    out bool output_per_sample_raw_matrix,
    src py   "../rna/stages/multi/multiplexing_method",
) using (
    mem_gb   = 1,
    threads  = 1,
    volatile = strict,
)

stage CALL_TAGS_MARGINAL(
    in  csv    filtered_barcodes,
    in  h5     filtered_feature_counts_matrix,
    in  string throughput,
    in  string library_type,
    out csv    marginal_tag_calls_per_cell,
    out csv    marginal_tag_frequencies,
    out json   tag_contaminant_info,
    src py     "stages/feature/call_tags_marginal",
) split (
)

stage CALL_TAGS_JIBES(
    in  csv    marginal_tag_calls_per_cell,
    in  csv    marginal_tag_frequencies,
    in  csv    filtered_barcodes,
    in  h5     filtered_feature_counts_matrix,
    in  h5     molecule_info,
    in  string throughput,
    in  string library_type,
    in  float  min_assignment_confidence,
    out json   jibes_parameters,
    out csv    jibes_model_summary,
    out json   jibes_summary_data,
    out csv    assignment_confidence_table,
    out csv    tag_calls_summary,
    out csv    tag_calls_per_cell,
    out json   tag_call_metrics,
    out json   cells_per_tag,
    out json   tag_umi_thresholds_json,
    out csv    tag_umi_thresholds_csv,
    out pickle tag_assigner_pickle,
    out json   non_singlet_barcodes,
    src py     "stages/feature/call_tags_jibes",
) split (
) using (
    volatile = strict,
)

stage DETERMINE_SAMPLE_ASSIGNMENTS(
    in  json[]             barcodes_per_tag,
    in  BarcodeAssignments force_sample_barcodes,
    in  csv                filtered_barcodes,
    in  json               multi_graph,
    in  json               non_singlet_barcodes,
    in  int                gem_well,
    in  h5                 raw_feature_bc_matrix,
    out json               cells_per_tag,
    out json               sample_barcodes,
    out json               sample_cell_barcodes,
    out json               non_singlet_barcodes,
    out map<json>          sample_summaries,
    out json               summary,
    src py                 "stages/multi/determine_sample_assignments",
) using (
    mem_gb   = 8,
    volatile = strict,
)

stage COMPUTE_EXTRA_MULTIPLEXING_METRICS(
    in  h5   molecule_info,
    in  h5   filtered_feature_counts_matrix,
    in  json multi_graph,
    in  json sample_cell_barcodes,
    in  json non_singlet_barcodes,
    out json summary,
    src py   "stages/multi/compute_extra_multiplexing_metrics",
) split (
) using (
    volatile = strict,
)

#
# @include "_assign_tags.mro"
#

pipeline _ASSIGN_TAGS(
    in  map<ChemistryDef>  chemistry_defs,
    in  csv                filtered_barcodes,
    in  h5                 filtered_feature_counts_matrix,
    in  h5                 raw_feature_bc_matrix,
    in  h5                 molecule_info,
    in  BarcodeAssignments force_sample_barcodes,
    in  json               multi_graph,
    in  int                gem_well,
    in  float              min_assignment_confidence,
    in  string             throughput,
    in  string             library_type,
    in  json               inferred_throughputs,
    out AssignTagsOuts     assign_tags_outs,
)
{
    call MULTIPLEXING_METHOD(
        multi_graph = self.multi_graph,
    )

    call CALL_TAGS_MARGINAL(
        filtered_barcodes = self.filtered_barcodes,
        filtered_feature_counts_matrix = self.filtered_feature_counts_matrix,
        throughput        = self.throughput,
        library_type      = self.library_type,
    ) using (
        disabled = MULTIPLEXING_METHOD.multiplexing_is_not_cmo,
    )

    call CALL_TAGS_JIBES(
        marginal_tag_calls_per_cell = CALL_TAGS_MARGINAL.marginal_tag_calls_per_cell,
        filtered_barcodes           = self.filtered_barcodes,
        filtered_feature_counts_matrix = self.filtered_feature_counts_matrix,
        molecule_info               = self.molecule_info,
        marginal_tag_frequencies    = CALL_TAGS_MARGINAL.marginal_tag_frequencies,
        throughput                  = self.throughput,
        min_assignment_confidence   = self.min_assignment_confidence,
        library_type                = self.library_type,
    ) using (
        disabled = MULTIPLEXING_METHOD.multiplexing_is_not_cmo,
    )

    call CALL_TAGS_RTL(
        chemistry_defs             = self.chemistry_defs,
        raw_feature_bc_matrix      = self.raw_feature_bc_matrix,
        filtered_feature_bc_matrix = self.filtered_feature_counts_matrix,
        multi_graph                = self.multi_graph,
    ) using (
        disabled = MULTIPLEXING_METHOD.multiplexing_is_not_rtl,
    )

    call CALL_TAGS_OH(
        chemistry_defs        = self.chemistry_defs,
        raw_feature_bc_matrix = self.raw_feature_bc_matrix,
    ) using (
        disabled = MULTIPLEXING_METHOD.multiplexing_is_not_oh,
    )

    call DETERMINE_SAMPLE_ASSIGNMENTS(
        barcodes_per_tag      = [
            CALL_TAGS_JIBES.cells_per_tag,
            CALL_TAGS_RTL.barcodes_per_tag,
            CALL_TAGS_OH.barcodes_per_tag,
        ],
        force_sample_barcodes = self.force_sample_barcodes,
        filtered_barcodes     = self.filtered_barcodes,
        multi_graph           = self.multi_graph,
        non_singlet_barcodes  = CALL_TAGS_JIBES.non_singlet_barcodes,
        gem_well              = self.gem_well,
        raw_feature_bc_matrix = self.raw_feature_bc_matrix,
    )

    call COMPUTE_EXTRA_MULTIPLEXING_METRICS(
        molecule_info        = self.molecule_info,
        filtered_feature_counts_matrix = self.filtered_feature_counts_matrix,
        multi_graph          = self.multi_graph,
        sample_cell_barcodes = DETERMINE_SAMPLE_ASSIGNMENTS.sample_cell_barcodes,
        non_singlet_barcodes = DETERMINE_SAMPLE_ASSIGNMENTS.non_singlet_barcodes,
    )

    call MERGE_METRICS(
        summaries = [
            CALL_TAGS_JIBES.tag_call_metrics,
            CALL_TAGS_RTL.summary,
            CALL_TAGS_OH.summary,
            DETERMINE_SAMPLE_ASSIGNMENTS.summary,
            COMPUTE_EXTRA_MULTIPLEXING_METRICS.summary,
        ],
    )

    return (
        assign_tags_outs = {
            assignment_confidence_table:   CALL_TAGS_JIBES.assignment_confidence_table,
            cells_per_tag:                 DETERMINE_SAMPLE_ASSIGNMENTS.cells_per_tag,
            force_sample_barcodes:         self.force_sample_barcodes,
            frp_gem_barcode_overlap:       CALL_TAGS_RTL.frp_gem_barcode_overlap,
            gem_well_inferred_throughputs: self.inferred_throughputs,
            jibes_model_summary:           CALL_TAGS_JIBES.jibes_model_summary,
            jibes_parameters:              CALL_TAGS_JIBES.jibes_parameters,
            jibes_summary_data:            CALL_TAGS_JIBES.jibes_summary_data,
            marginal_tag_frequencies:      CALL_TAGS_MARGINAL.marginal_tag_frequencies,
            multiplexing_is_not_cmo:       MULTIPLEXING_METHOD.multiplexing_is_not_cmo,
            non_singlet_barcodes:          DETERMINE_SAMPLE_ASSIGNMENTS.non_singlet_barcodes,
            output_per_sample_raw_matrix:  MULTIPLEXING_METHOD.output_per_sample_raw_matrix,
            sample_assignment_metrics:     DETERMINE_SAMPLE_ASSIGNMENTS.sample_summaries,
            sample_barcodes:               DETERMINE_SAMPLE_ASSIGNMENTS.sample_barcodes,
            sample_cell_barcodes:          DETERMINE_SAMPLE_ASSIGNMENTS.sample_cell_barcodes,
            tag_assigner_pickle:           CALL_TAGS_JIBES.tag_assigner_pickle,
            tag_call_metrics:              MERGE_METRICS.summary,
            tag_calls_per_cell:            CALL_TAGS_JIBES.tag_calls_per_cell,
            tag_calls_summary:             CALL_TAGS_JIBES.tag_calls_summary,
            tag_contaminant_info:          CALL_TAGS_MARGINAL.tag_contaminant_info,
            tag_umi_thresholds_csv:        CALL_TAGS_JIBES.tag_umi_thresholds_csv,
            tag_umi_thresholds_json:       CALL_TAGS_JIBES.tag_umi_thresholds_json,
        },
    )
}

#
# @include "_basic_sc_rna_counter_stages.mro"
#

stage FILTER_BARCODES(
    in  map<ChemistryDef> chemistry_defs,
    in  string            sample_id,
    in  h5                matrices_h5,
    in  csv               barcode_correction_csv,
    in  bool              is_antibody_only,
    in  path              reference_path,
    in  int[]             gem_groups,
    in  CellCalling       config,
    in  csv               target_set,
    in  json              multi_graph,
    in  csv               per_barcode_metrics,
    in  bool              is_spatial,
    out json              summary,
    out csv               filtered_barcodes,
    out csv               aggregate_barcodes,
    out h5                filtered_matrices_h5,
    out path              filtered_matrices_mex,
    out csv               nonambient_calls,
    out csv               mitochondrial_summary,
    out csv               isotype_normalization_factors,
    src py                "stages/counter/filter_barcodes",
) split (
    in  ProbeBCDef        probe_bc_def,
    out json              filtered_metrics_groups,
    out bincode           filtered_bcs_groups,
    out csv               co_mitochondrial_summary,
) using (
    mem_gb   = 8,
    volatile = strict,
)

stage INFER_GEM_WELL_THROUGHPUT(
    in  map<ChemistryDef> chemistry_defs,
    in  string            throughput,
    in  h5                filtered_feature_counts_matrix,
    in  path              reference_path,
    in  h5                barcode_summary_h5,
    out string            throughput,
    out json              inferred_throughputs,
    src py                "stages/feature/infer_gem_well_throughput",
) using (
    mem_gb   = 2,
    volatile = strict,
)

stage MULTI_WRITE_PER_SAMPLE_MATRICES(
    in  h5               matrix_h5,
    in  h5               raw_matrix_h5,
    in  csv              filtered_barcodes,
    in  csv              aggregate_barcodes,
    in  json             sample_barcodes,
    in  json             sample_cell_barcodes,
    in  json             multi_graph,
    in  map<h5>          sample_raw_probe_bc_matrices,
    in  map<csv>         samples_per_probe_metrics,
    out SampleMatrices[] sample_matrices,
    src py               "stages/multi/multi_write_per_sample_matrices",
) split (
    in  string           sample,
    out SampleMatrices   matrices,
) using (
    mem_gb   = 4,
    volatile = strict,
)

stage SUMMARIZE_BASIC_REPORTS(
    in  string           sample,
    in  h5               matrices_h5,
    in  csv              filtered_barcodes,
    in  csv              per_barcode_metrics,
    in  json             matrix_computer_summary,
    in  h5               barcode_summary,
    in  CellCallingParam recovered_cells,
    in  path             reference_path,
    in  json[]           summary_jsons,
    in  bool             sample_bcs_only,
    in  tps.json         target_panel_summary,
    out json             summary,
    src py               "stages/counter/summarize_basic_reports",
) split (
) using (
    volatile = strict,
)

stage DISABLE_STAGES(
    in  bool  no_bam,
    in  bool  disable_multi,
    in  bool  is_pd,
    in  bool  is_visium_hd,
    in  h5    raw_feature_bc_matrix,
    in  csf[] probe_barcode_counts,
    out bool  disable_legacy_bam,
    out bool  disable_sample_bams,
    out bool  disable_assign_tags,
    out bool  disable_subsampling,
    out bool  no_probe_barcode_counts,
    out bool  no_probe_barcode_matrix_demux,
    src py    "stages/multi/disable_stages",
) using (
    volatile = strict,
)

stage SUBSAMPLE_READS(
    in  h5     molecule_info,
    in  csv    filtered_barcodes,
    in  string target_mode,
    out json   summary,
    src py     "stages/counter/subsample_reads",
) split (
    in  int    chunk_start,
    in  int    chunk_len,
    in  map[]  subsample_info,
    out pickle metrics,
) using (
    mem_gb   = 4,
    volatile = strict,
)

stage COMPUTE_CORRECTION_FACTOR(
    in  h5    v1_filtered_fbm,
    in  json  barcodes_under_tissue,
    out float correction_factor,
    out json  affected_barcodes,
    out bool  disable_downsampling,
    src py    "stages/spatial/compute_correction_factor",
) using (
    volatile = strict,
)

stage DISABLE_CORRECTION_FACTOR(
    in  h5   v1_filtered_fbm,
    out bool disable_correction_factor,
    src py   "stages/spatial/disable_correction_factor",
) using (
    volatile = strict,
)

stage CHECK_CORRECTION_FACTOR(
    in  h5 v1_filtered_fbm,
    in  h5 filtered_fbm,
    src py "stages/spatial/check_correction_factor",
) using (
    volatile = strict,
)

#
# @include "_slfe_cells_reporter.mro"
#

pipeline _SLFE_CELLS_REPORTER(
    in  map<ChemistryDef> chemistry_defs,
    in  path              reference_path,
    in  CellCallingParam  recovered_cells,
    in  CellCallingParam  force_cells,
    in  frf.bincode       slfe_feature_reference,
    in  tps.json          target_panel_summary,
    in  h5                matrices_h5,
    in  map[]             read_chunks,
    in  int               gem_well,
    in  bui[]             report_mol_inputs,
    in  json              matrix_computer_summary,
    in  h5                barcode_summary,
    in  csv               filtered_barcodes,
    in  csv               per_probe_metrics,
    in  json              filter_barcodes_summary,
    in  csv               per_barcode_metrics,
    in  bool              include_introns,
    in  bool              filter_probes,
    in  bool              disable_subsampling,
    in  string            multi_config_sha,
    in  bi.bincode        barcode_index,
    in  string            slide_serial_capture_area,
    out json              summary,
    out h5                molecule_info,
)
{
    call WRITE_MOLECULE_INFO(
        chemistry_defs            = self.chemistry_defs,
        gem_well                  = self.gem_well,
        counts_bc_order           = self.report_mol_inputs,
        reference_path            = self.reference_path,
        read_chunks               = self.read_chunks,
        feature_reference         = self.slfe_feature_reference,
        target_panel_summary      = self.target_panel_summary,
        matrix_computer_summary   = self.matrix_computer_summary,
        recovered_cells           = self.recovered_cells,
        force_cells               = self.force_cells,
        filtered_barcodes         = self.filtered_barcodes,
        per_probe_metrics         = self.per_probe_metrics,
        include_introns           = self.include_introns,
        filter_probes             = self.filter_probes,
        multi_config_sha          = self.multi_config_sha,
        sample_barcodes           = null,
        per_sample_metrics        = null,
        barcode_index             = self.barcode_index,
        slide_serial_capture_area = self.slide_serial_capture_area,
    )

    call SUBSAMPLE_READS(
        molecule_info     = WRITE_MOLECULE_INFO.single_mol_info.h5_file,
        filtered_barcodes = self.filtered_barcodes,
        target_mode       = null,
    ) using (
        disabled = self.disable_subsampling,
        volatile = true,
    )

    call SUMMARIZE_BASIC_REPORTS(
        sample                  = null,
        matrices_h5             = self.matrices_h5,
        filtered_barcodes       = self.filtered_barcodes,
        per_barcode_metrics     = self.per_barcode_metrics,
        matrix_computer_summary = self.matrix_computer_summary,
        barcode_summary         = self.barcode_summary,
        recovered_cells         = self.recovered_cells,
        reference_path          = self.reference_path,
        # this is being run "library level", use all bcs
        sample_bcs_only         = false,
        target_panel_summary    = self.target_panel_summary,
        summary_jsons           = [
            self.matrix_computer_summary,
            SUBSAMPLE_READS.summary,
            WRITE_MOLECULE_INFO.single_mol_info.summary,
            self.filter_barcodes_summary,
        ],
    )

    return (
        summary       = SUMMARIZE_BASIC_REPORTS.summary,
        molecule_info = WRITE_MOLECULE_INFO.single_mol_info.h5_file,
    )
}

# CELLS_REPORTER but for sliced samples, does not write the molecule info
pipeline _SAMPLE_CELLS_REPORTER(
    in  string           sample,
    in  h5               molecule_info,
    in  path             reference_path,
    in  CellCallingParam recovered_cells,
    in  h5               matrices_h5,
    in  json             matrix_computer_summary,
    in  csv              filtered_barcodes,
    in  csv              per_barcode_metrics,
    in  h5               barcode_summary,
    in  json             sample_assignment_metrics,
    in  json             count_analyzer_metrics,
    in  json             crispr_analyzer_metrics,
    in  json             targeted_analyzer_metrics,
    in  tps.json         target_panel_summary,
    out json             summary,
)
{
    call SUBSAMPLE_READS(
        molecule_info     = self.molecule_info,
        filtered_barcodes = self.filtered_barcodes,
        target_mode       = null,
    ) using (
        volatile = true,
    )

    call SUMMARIZE_BASIC_REPORTS(
        sample                  = self.sample,
        matrices_h5             = self.matrices_h5,
        filtered_barcodes       = self.filtered_barcodes,
        per_barcode_metrics     = self.per_barcode_metrics,
        matrix_computer_summary = self.matrix_computer_summary,
        barcode_summary         = self.barcode_summary,
        recovered_cells         = self.recovered_cells,
        reference_path          = self.reference_path,
        # we want "all reads" etc to include only those with sample barcodes.
        sample_bcs_only         = true,
        target_panel_summary    = self.target_panel_summary,
        summary_jsons           = [
            self.matrix_computer_summary,
            SUBSAMPLE_READS.summary,
            self.sample_assignment_metrics,
            self.count_analyzer_metrics,
            self.crispr_analyzer_metrics,
            self.targeted_analyzer_metrics,
        ],
    )

    return (
        summary = SUMMARIZE_BASIC_REPORTS.summary,
    )
}

#
# @include "_slfe_partial_first_pass.mro"
#

# Inputs copied crom _cr_lib_stages. Cleaner way to do this?
pipeline _SLFE_PARTIAL_FIRST_PASS(
    in  int               gem_well,
    in  map[]             read_chunks,
    in  path              reference_path,
    in  ReadShards        read_shards,
    in  fbc.bincode       feature_counts,
    in  frf.bincode       feature_reference,
    in  csv               target_set,
    in  map<ChemistryDef> chemistry_defs,
    in  bool              include_introns,
    in  string            aligner,
    in  bool              is_pd,
    in  int               trim_polya_min_score,
    in  int               trim_tso_min_score,
    in  tbcc.bincode      total_barcode_counts,
    in  bcc.bincode       corrected_barcode_counts,
    out int               umi_read_count_threshold,
    out json              umi_filtering_summary,
)
{
    call SUBSAMPLE_BARCODES(
        corrected_barcode_counts = self.corrected_barcode_counts,
    )

    call ALIGN_AND_COUNT as INITIAL_ALIGN_AND_COUNT(
        gem_well                    = self.gem_well,
        read_chunks                 = self.read_chunks,
        reference_path              = self.reference_path,
        read_shards                 = self.read_shards,
        feature_counts              = self.feature_counts,
        feature_reference           = self.feature_reference,
        target_set                  = self.target_set,
        chemistry_defs              = self.chemistry_defs,
        include_exons               = true,
        include_introns             = self.include_introns,
        no_bam                      = true,
        aligner                     = self.aligner,
        is_pd                       = self.is_pd,
        transcriptome_min_score     = 30,
        trim_polya_min_score        = self.trim_polya_min_score,
        trim_tso_min_score          = self.trim_tso_min_score,
        targeted_umi_min_read_count = null,
        total_barcode_counts        = self.total_barcode_counts,
        barcode_subset              = SUBSAMPLE_BARCODES.barcode_subset,
        chevron_correction_factor   = null,
        chevron_affected_barcodes   = null,
    )

    call SET_TARGETED_UMI_FILTER(
        bc_umi_info       = INITIAL_ALIGN_AND_COUNT.bc_umi_info,
        feature_reference = self.feature_reference,
    )

    return (
        umi_read_count_threshold = SET_TARGETED_UMI_FILTER.umi_read_count_threshold,
        umi_filtering_summary    = SET_TARGETED_UMI_FILTER.summary,
    )
}

#
# @include "_slfe_matrix_computer.mro"
#

pipeline MAKE_READ_SHARDS_STRUCT(
    in  shard[]    valid_reads,
    in  shard[]    corrected_reads,
    in  shard[]    invalid_reads,
    out ReadShards read_shards,
)
{
    return (
        read_shards = {
            corrected_reads: self.corrected_reads,
            invalid_reads:   self.invalid_reads,
            valid_reads:     self.valid_reads,
        },
    )
}

pipeline _SLFE_MATRIX_COMPUTER(
    in  string            sample_id,
    in  map<ChemistryDef> chemistry_defs,
    in  json              barcodes_under_tissue,
    in  bool              is_pd,
    in  map[]             chunks,
    in  path              reference_path,
    in  string[]          libraries_to_translate,
    in  float             subsample_rate,
    in  int               initial_reads,
    in  int               r1_length,
    in  int               r2_length,
    in  int               trim_polya_min_score,
    in  int               trim_tso_min_score,
    in  int               min_reads_to_report_bc,
    in  csv               feature_reference,
    in  csv               target_features,
    in  csv               target_set,
    in  string            target_set_name,
    in  bool              include_exons,
    in  bool              include_introns,
    in  bool              no_bam,
    in  string            aligner,
    in  bool              disable_target_umi_filter,
    in  FeatureConfig     feature_config,
    # Note: _SLFE_MATRIX_COMPUTER processes data from a single gem well.
    in  int               gem_well,
    in  h5                v1_filtered_fbm,
    out frf.bincode       slfe_feature_reference,
    out csv               barcode_correction_csv,
    out h5                barcode_summary,
    out h5                raw_gene_bc_matrices_h5,
    out path              raw_gene_bc_matrices_mex,
    out ReadShards        read_shards,
    out csf[]             counts_bc_order,
    out bui[]             report_mol_inputs,
    out json              summary,
    out AnnotationFiles   annotation_files,
    out csv               per_barcode_metrics,
    out bmsf[]            per_barcode_metrics_shard,
    out bui[]             bc_umi_info,
    out csf[]             probe_barcode_counts,
    out path              bam_header,
    out asf[]             alignments,
    out map[]             read_chunks,
    out SampleMetrics[]   multi_metrics,
    out json              gem_well_alignment_metrics,
    out bi.bincode        barcode_index,
    out smf.json          sequencing_metrics,
    ### One file has bc_counts from MAKE_SHARD for use by ATAC
    out bcc.bincode       make_shard_bc_counts,
    ### This has total barcodes from BARCODE_CORRECTION for use in Spatial
    out tbcc.bincode      barcode_counts,
    out bool              no_star_alignments,
)
{
    call MAKE_SHARD(
        gem_well               = self.gem_well,
        chemistry_defs         = self.chemistry_defs,
        read_chunks            = self.chunks,
        r1_length              = self.r1_length,
        r2_length              = self.r2_length,
        subsample_rate         = self.subsample_rate,
        initial_read_pairs     = self.initial_reads,
        reference_path         = self.reference_path,
        target_features        = self.target_features,
        # TODO: Replace these with the target_panel_summary
        target_set             = self.target_set,
        target_set_name        = self.target_set_name,
        feature_reference_path = self.feature_reference,
        libraries_to_translate = self.libraries_to_translate,
        feature_config         = self.feature_config,
    )

    call MAKE_CORRECTION_MAP(
        chemistry_defs         = self.chemistry_defs,
        barcode_segment_counts = MAKE_SHARD.barcode_segment_counts,
    )

    call BARCODE_CORRECTION(
        gem_well               = self.gem_well,
        barcode_counts         = MAKE_SHARD.barcode_counts,
        barcode_segment_counts = MAKE_SHARD.barcode_segment_counts,
        chemistry_defs         = self.chemistry_defs,
        invalid_uncorrected    = MAKE_SHARD.invalid,
        valid_read_metrics     = MAKE_SHARD.bc_correct_summary,
        libraries_to_translate = self.libraries_to_translate,
        min_reads_to_report_bc = self.min_reads_to_report_bc,
        correction_map         = MAKE_CORRECTION_MAP.correction_map,
    )

    call MAKE_READ_SHARDS_STRUCT(
        valid_reads     = MAKE_SHARD.valid,
        corrected_reads = BARCODE_CORRECTION.valid_corrected,
        invalid_reads   = BARCODE_CORRECTION.invalid,
    )

    call _SLFE_PARTIAL_FIRST_PASS(
        gem_well                 = self.gem_well,
        read_chunks              = self.chunks,
        reference_path           = self.reference_path,
        read_shards              = MAKE_READ_SHARDS_STRUCT.read_shards,
        feature_counts           = MAKE_SHARD.feature_counts,
        feature_reference        = MAKE_SHARD.feature_reference,
        target_set               = self.target_set,
        chemistry_defs           = self.chemistry_defs,
        include_introns          = self.include_introns,
        aligner                  = self.aligner,
        is_pd                    = self.is_pd,
        trim_polya_min_score     = self.trim_polya_min_score,
        trim_tso_min_score       = self.trim_tso_min_score,
        total_barcode_counts     = BARCODE_CORRECTION.total_barcode_counts,
        corrected_barcode_counts = BARCODE_CORRECTION.corrected_barcode_counts,
    ) using (
        disabled = self.disable_target_umi_filter,
    )

    call DISABLE_CORRECTION_FACTOR(
        v1_filtered_fbm = self.v1_filtered_fbm,
    )

    call COMPUTE_CORRECTION_FACTOR(
        v1_filtered_fbm       = self.v1_filtered_fbm,
        barcodes_under_tissue = self.barcodes_under_tissue,
    ) using (
        disabled = DISABLE_CORRECTION_FACTOR.disable_correction_factor,
    )

    call ALIGN_AND_COUNT(
        gem_well                    = self.gem_well,
        read_chunks                 = self.chunks,
        reference_path              = self.reference_path,
        read_shards                 = MAKE_READ_SHARDS_STRUCT.read_shards,
        feature_counts              = MAKE_SHARD.feature_counts,
        feature_reference           = MAKE_SHARD.feature_reference,
        target_set                  = self.target_set,
        chemistry_defs              = self.chemistry_defs,
        include_exons               = self.include_exons,
        include_introns             = self.include_introns,
        no_bam                      = self.no_bam,
        aligner                     = self.aligner,
        is_pd                       = self.is_pd,
        transcriptome_min_score     = 30,
        trim_polya_min_score        = self.trim_polya_min_score,
        trim_tso_min_score          = self.trim_tso_min_score,
        targeted_umi_min_read_count = _SLFE_PARTIAL_FIRST_PASS.umi_read_count_threshold,
        total_barcode_counts        = BARCODE_CORRECTION.total_barcode_counts,
        barcode_subset              = null,
        chevron_correction_factor   = COMPUTE_CORRECTION_FACTOR.correction_factor,
        chevron_affected_barcodes   = COMPUTE_CORRECTION_FACTOR.affected_barcodes,
    )

    call COLLATE_METRICS(
        per_barcode_metrics = ALIGN_AND_COUNT.per_barcode_metrics,
        reference_path      = self.reference_path,
        feature_reference   = MAKE_SHARD.feature_reference,
        filtered_barcodes   = null,
        aggregate_barcodes  = null,
        sample_barcodes     = null,
    )

    call WRITE_BARCODE_INDEX(
        barcode_counts        = BARCODE_CORRECTION.corrected_barcode_counts,
        barcodes_under_tissue = self.barcodes_under_tissue,
    )

    call WRITE_BARCODE_SUMMARY(
        per_barcode_metrics = ALIGN_AND_COUNT.per_barcode_metrics,
        feature_reference   = MAKE_SHARD.feature_reference,
        barcode_index       = WRITE_BARCODE_INDEX.barcode_index,
    )

    call WRITE_H5_MATRIX(
        gem_well          = self.gem_well,
        counts            = ALIGN_AND_COUNT.counts_bc_order,
        feature_reference = MAKE_SHARD.feature_reference,
        chemistry_defs    = self.chemistry_defs,
        sample_id         = self.sample_id,
        barcode_index     = WRITE_BARCODE_INDEX.barcode_index,
    )

    call WRITE_MATRIX_MARKET(
        counts            = ALIGN_AND_COUNT.counts_bc_order,
        feature_reference = MAKE_SHARD.feature_reference,
        barcode_index     = WRITE_BARCODE_INDEX.barcode_index,
    )

    call MERGE_METRICS(
        summaries = [
            MAKE_SHARD.summary,
            BARCODE_CORRECTION.summary,
            _SLFE_PARTIAL_FIRST_PASS.umi_filtering_summary,
            ALIGN_AND_COUNT.summary,
            COLLATE_METRICS.summary,
        ],
    )

    return (
        barcode_correction_csv     = ALIGN_AND_COUNT.barcode_summary,
        barcode_summary            = WRITE_BARCODE_SUMMARY.barcode_summary,
        raw_gene_bc_matrices_h5    = WRITE_H5_MATRIX.matrix,
        raw_gene_bc_matrices_mex   = WRITE_MATRIX_MARKET.feature_bc_matrix,
        read_shards                = MAKE_READ_SHARDS_STRUCT.read_shards,
        counts_bc_order            = ALIGN_AND_COUNT.counts_bc_order,
        report_mol_inputs          = ALIGN_AND_COUNT.bc_umi_info,
        summary                    = MERGE_METRICS.summary,
        slfe_feature_reference     = MAKE_SHARD.feature_reference,
        annotation_files           = ALIGN_AND_COUNT.annotation_files,
        per_barcode_metrics        = COLLATE_METRICS.per_barcode_metrics,
        per_barcode_metrics_shard  = ALIGN_AND_COUNT.per_barcode_metrics,
        bc_umi_info                = ALIGN_AND_COUNT.bc_umi_info,
        bam_header                 = ALIGN_AND_COUNT.bam_header,
        alignments                 = ALIGN_AND_COUNT.pos_sorted,
        read_chunks                = self.chunks,
        multi_metrics              = COLLATE_METRICS.multi_metrics,
        gem_well_alignment_metrics = COLLATE_METRICS.summary,
        barcode_index              = WRITE_BARCODE_INDEX.barcode_index,
        sequencing_metrics         = MAKE_SHARD.sequencing_metrics,
        make_shard_bc_counts       = MAKE_SHARD.barcode_counts,
        barcode_counts             = BARCODE_CORRECTION.total_barcode_counts,
        probe_barcode_counts       = ALIGN_AND_COUNT.probe_barcode_counts,
        no_star_alignments         = ALIGN_AND_COUNT.no_star_alignments,
    )
}

#
# @include "_basic_sc_rna_counter.mro"
#

pipeline _BASIC_SC_RNA_COUNTER(
    in  int                  gem_well,
    in  string               sample_id,
    in  map<ChemistryDef>    chemistry_defs,
    in  bool                 is_antibody_only,
    in  bool                 is_pd,
    in  map[]                chunks,
    in  path                 reference_path,
    in  CellCalling          cell_calling_config,
    in  string[]             libraries_to_translate,
    in  float                subsample_rate,
    in  int                  initial_reads,
    in  int                  r1_length,
    in  int                  r2_length,
    in  int                  trim_polya_min_score,
    in  int                  trim_tso_min_score,
    in  int                  min_reads_to_report_bc,
    in  csv                  feature_reference,
    in  csv                  target_features,
    in  csv                  target_set,
    in  string               target_set_name,
    in  tps.json             target_panel_summary,
    in  bool                 include_exons,
    in  bool                 include_introns,
    in  bool                 filter_probes,
    in  string               aligner,
    in  bool                 disable_target_umi_filter,
    in  string               multi_config_sha,
    in  bool                 no_bam,
    in  BarcodeAssignments   force_sample_barcodes,
    in  bool                 disable_multi,
    in  json                 multi_graph,
    in  bool                 is_spatial,
    in  bool                 is_visium_hd,
    in  float                min_assignment_confidence,
    in  string               slide_serial_capture_area,
    in  FeatureConfig        feature_config,
    in  h5                   v1_filtered_fbm,
    out csv                  filtered_barcodes,
    out csv                  aggregate_barcodes,
    out csv                  nonambient_cell_calls,
    out csv                  barcode_correction_csv,
    out path                 bam_header,
    out bam                  possorted_genome_bam,
    out bam.bai              possorted_genome_bai_index,
    out bam.csi              possorted_genome_csi_index,
    out json                 summary,
    out h5                   barcode_summary,
    out tbcc.bincode         barcode_counts,
    out h5                   molecule_info,
    out h5                   raw_gene_bc_matrices_h5,
    out path                 raw_gene_bc_matrices_mex,
    out h5                   filtered_gene_bc_matrices_h5,
    out path                 filtered_gene_bc_matrices_mex,
    out int[]                gem_groups,
    out ReadShards           read_shards,
    out AnnotationFiles      annotation_files,
    out smf.json             sequencing_metrics,
    out csv                  per_probe_metrics,
    out h5                   raw_probe_bc_matrix,
    # subset of summary json, needed only for verifying correct sample metrics
    out json                 gem_well_alignment_metrics,
    # sliced outputs for multi
    out AssignTagsOuts       assign_tags,
    out SampleBamFile[]      multi_pos_sorted_bam,
    out SampleMoleculeInfo[] multi_molecule_info,
    out SampleMetrics[]      multi_metrics,
    out SampleMatrices[]     multi_matrices,
    out map<json>            sample_assignment_metrics,
    out json                 sample_barcodes,
    # everything below here is needed only for gem group merging
    out csv                  per_barcode_metrics,
    out csv                  isotype_normalization_factors,
    out bmsf[]               per_barcode_metrics_shard,
    out bui[]                bc_umi_info,
    out asf[]                alignments,
    out map[]                read_chunks,
    out string               target_set_name,
    out frf.bincode          slfe_feature_reference,
    # Shard files of feature x barcode counts sorted by barcode
    out csf[]                counts_bc_order,
    out bool                 no_star_alignments,
    out bi.bincode           barcode_index,
)
{
    call _SLFE_MATRIX_COMPUTER as _MATRIX_COMPUTER(
        gem_well                  = self.gem_well,
        sample_id                 = self.sample_id,
        chemistry_defs            = self.chemistry_defs,
        barcodes_under_tissue     = self.cell_calling_config.cell_barcodes,
        is_pd                     = self.is_pd,
        chunks                    = self.chunks,
        reference_path            = self.reference_path,
        libraries_to_translate    = self.libraries_to_translate,
        subsample_rate            = self.subsample_rate,
        initial_reads             = self.initial_reads,
        r1_length                 = self.r1_length,
        r2_length                 = self.r2_length,
        trim_polya_min_score      = self.trim_polya_min_score,
        trim_tso_min_score        = self.trim_tso_min_score,
        min_reads_to_report_bc    = self.min_reads_to_report_bc,
        feature_reference         = self.feature_reference,
        target_features           = self.target_features,
        target_set                = self.target_set,
        target_set_name           = self.target_set_name,
        include_exons             = self.include_exons,
        include_introns           = self.include_introns,
        no_bam                    = self.no_bam,
        aligner                   = self.aligner,
        disable_target_umi_filter = self.disable_target_umi_filter,
        feature_config            = self.feature_config,
        v1_filtered_fbm           = self.v1_filtered_fbm,
    )

    call FILTER_BARCODES(
        chemistry_defs         = self.chemistry_defs,
        sample_id              = self.sample_id,
        matrices_h5            = _MATRIX_COMPUTER.raw_gene_bc_matrices_h5,
        barcode_correction_csv = _MATRIX_COMPUTER.barcode_correction_csv,
        config                 = self.cell_calling_config,
        gem_groups             = [self.gem_well],
        is_antibody_only       = self.is_antibody_only,
        reference_path         = self.reference_path,
        target_set             = self.target_set,
        multi_graph            = self.multi_graph,
        per_barcode_metrics    = _MATRIX_COMPUTER.per_barcode_metrics,
        is_spatial             = self.is_spatial,
    )

    call CHECK_CORRECTION_FACTOR(
        v1_filtered_fbm = self.v1_filtered_fbm,
        filtered_fbm    = FILTER_BARCODES.filtered_matrices_h5,
    )

    call DISABLE_STAGES(
        raw_feature_bc_matrix = _MATRIX_COMPUTER.raw_gene_bc_matrices_h5,
        probe_barcode_counts  = _MATRIX_COMPUTER.probe_barcode_counts,
        *                     = self,
    )

    call COLLATE_PROBE_METRICS(
        probe_barcode_counts = _MATRIX_COMPUTER.probe_barcode_counts,
        reference_path       = self.reference_path,
        probe_set            = self.target_set,
        filtered_barcodes    = FILTER_BARCODES.filtered_barcodes,
        probe_set_name       = self.target_set_name,
        barcode_index_path   = _MATRIX_COMPUTER.barcode_index,
    ) using (
        disabled = DISABLE_STAGES.no_probe_barcode_counts,
    )

    call WRITE_POS_BAM(
        target_set_name           = self.target_set_name,
        sample_barcodes           = null,
        slide_serial_capture_area = self.slide_serial_capture_area,
        *                         = _MATRIX_COMPUTER,
    ) using (
        disabled = DISABLE_STAGES.disable_legacy_bam,
    )

    call _SLFE_CELLS_REPORTER as _CELLS_REPORTER(
        chemistry_defs            = self.chemistry_defs,
        gem_well                  = self.gem_well,
        reference_path            = self.reference_path,
        recovered_cells           = self.cell_calling_config.recovered_cells,
        force_cells               = self.cell_calling_config.force_cells,
        slfe_feature_reference    = _MATRIX_COMPUTER.slfe_feature_reference,
        target_panel_summary      = self.target_panel_summary,
        matrices_h5               = _MATRIX_COMPUTER.raw_gene_bc_matrices_h5,
        read_chunks               = self.chunks,
        report_mol_inputs         = _MATRIX_COMPUTER.report_mol_inputs,
        matrix_computer_summary   = _MATRIX_COMPUTER.summary,
        barcode_summary           = _MATRIX_COMPUTER.barcode_summary,
        filtered_barcodes         = FILTER_BARCODES.filtered_barcodes,
        per_probe_metrics         = COLLATE_PROBE_METRICS.per_probe_metrics,
        filter_barcodes_summary   = FILTER_BARCODES.summary,
        per_barcode_metrics       = _MATRIX_COMPUTER.per_barcode_metrics,
        include_introns           = self.include_introns,
        filter_probes             = self.filter_probes,
        multi_config_sha          = self.multi_config_sha,
        disable_subsampling       = DISABLE_STAGES.disable_subsampling,
        barcode_index             = _MATRIX_COMPUTER.barcode_index,
        slide_serial_capture_area = self.slide_serial_capture_area,
    )

    call INFER_GEM_WELL_THROUGHPUT(
        chemistry_defs     = self.chemistry_defs,
        throughput         = null,
        filtered_feature_counts_matrix = FILTER_BARCODES.filtered_matrices_h5,
        reference_path     = self.reference_path,
        barcode_summary_h5 = _MATRIX_COMPUTER.barcode_summary,
    ) using (
        disabled = self.is_spatial,
    )

    call _ASSIGN_TAGS(
        chemistry_defs            = self.chemistry_defs,
        filtered_barcodes         = FILTER_BARCODES.filtered_barcodes,
        filtered_feature_counts_matrix = FILTER_BARCODES.filtered_matrices_h5,
        raw_feature_bc_matrix     = _MATRIX_COMPUTER.raw_gene_bc_matrices_h5,
        molecule_info             = _CELLS_REPORTER.molecule_info,
        multi_graph               = self.multi_graph,
        force_sample_barcodes     = self.force_sample_barcodes,
        gem_well                  = self.gem_well,
        min_assignment_confidence = self.min_assignment_confidence,
        throughput                = INFER_GEM_WELL_THROUGHPUT.throughput,
        inferred_throughputs      = INFER_GEM_WELL_THROUGHPUT.inferred_throughputs,
        # default=null is multiplexing, but this enables others e.g. antigen capture
        library_type              = null,
    ) using (
        disabled = DISABLE_STAGES.disable_assign_tags,
    )

    # stages/pipelines below here are for multiplexing sliced outputs
    # sample_barcodes is passed on by the _CELLS_REPORTER
    # and was either calculated from tags or is equal to self.force_sample_barcodes
    # in multi-gem world a couple of these things (BAM writing, metrics) should be completely migrated to MERGE_GEM_WELLS_AND_SLICE_CELLS
    # but without multi-gem there isn't explicitly a need to run that stage and it does unnecessary things like running Aggr.

    call DEMUX_PROBE_BC_MATRIX(
        probe_barcode_counts = _MATRIX_COMPUTER.probe_barcode_counts,
        reference_path       = self.reference_path,
        probe_set            = self.target_set,
        probe_set_name       = self.target_set_name,
        sample_barcodes      = _ASSIGN_TAGS.assign_tags_outs.sample_barcodes,
        sample_cell_barcodes = _ASSIGN_TAGS.assign_tags_outs.sample_cell_barcodes,
    ) using (
        disabled = DISABLE_STAGES.no_probe_barcode_matrix_demux,
    )

    call MULTI_WRITE_PER_SAMPLE_MATRICES(
        matrix_h5                    = FILTER_BARCODES.filtered_matrices_h5,
        raw_matrix_h5                = _MATRIX_COMPUTER.raw_gene_bc_matrices_h5,
        sample_barcodes              = _ASSIGN_TAGS.assign_tags_outs.sample_barcodes,
        sample_cell_barcodes         = _ASSIGN_TAGS.assign_tags_outs.sample_cell_barcodes,
        multi_graph                  = self.multi_graph,
        sample_raw_probe_bc_matrices = DEMUX_PROBE_BC_MATRIX.sample_raw_probe_bc_matrices,
        samples_per_probe_metrics    = DEMUX_PROBE_BC_MATRIX.samples_per_probe_metrics,
        filtered_barcodes            = FILTER_BARCODES.filtered_barcodes,
        aggregate_barcodes           = FILTER_BARCODES.aggregate_barcodes,
    ) using (
        disabled = self.disable_multi,
    )

    call WRITE_POS_BAM as MULTI_WRITE_PER_SAMPLE_BAM(
        target_set_name           = self.target_set_name,
        slide_serial_capture_area = self.slide_serial_capture_area,
        sample_barcodes           = _ASSIGN_TAGS.assign_tags_outs.sample_barcodes,
        *                         = _MATRIX_COMPUTER,
    ) using (
        disabled = DISABLE_STAGES.disable_sample_bams,
    )

    call COLLATE_METRICS as MULTI_COLLATE_PER_SAMPLE_METRICS(
        per_barcode_metrics = _MATRIX_COMPUTER.per_barcode_metrics_shard,
        reference_path      = self.reference_path,
        feature_reference   = _MATRIX_COMPUTER.slfe_feature_reference,
        filtered_barcodes   = FILTER_BARCODES.filtered_barcodes,
        aggregate_barcodes  = FILTER_BARCODES.aggregate_barcodes,
        sample_barcodes     = _ASSIGN_TAGS.assign_tags_outs.sample_barcodes,
    ) using (
        disabled = self.disable_multi,
    )

    call WRITE_MOLECULE_INFO as MULTI_WRITE_PER_SAMPLE_MOLECULE_INFO(
        chemistry_defs            = self.chemistry_defs,
        gem_well                  = self.gem_well,
        counts_bc_order           = _MATRIX_COMPUTER.report_mol_inputs,
        reference_path            = self.reference_path,
        read_chunks               = self.chunks,
        feature_reference         = _MATRIX_COMPUTER.slfe_feature_reference,
        target_panel_summary      = self.target_panel_summary,
        matrix_computer_summary   = _MATRIX_COMPUTER.summary,
        recovered_cells           = self.cell_calling_config.recovered_cells,
        force_cells               = self.cell_calling_config.force_cells,
        filtered_barcodes         = FILTER_BARCODES.filtered_barcodes,
        per_probe_metrics         = COLLATE_PROBE_METRICS.per_probe_metrics,
        include_introns           = self.include_introns,
        filter_probes             = self.filter_probes,
        multi_config_sha          = self.multi_config_sha,
        sample_barcodes           = _ASSIGN_TAGS.assign_tags_outs.sample_barcodes,
        per_sample_metrics        = MULTI_COLLATE_PER_SAMPLE_METRICS.multi_metrics,
        barcode_index             = _MATRIX_COMPUTER.barcode_index,
        slide_serial_capture_area = self.slide_serial_capture_area,
    ) using (
        disabled = self.disable_multi,
    )

    call MERGE_METRICS(
        summaries = [
            _CELLS_REPORTER.summary,
            _ASSIGN_TAGS.assign_tags_outs.tag_call_metrics,
            COLLATE_PROBE_METRICS.estimated_gdna_metrics,
        ],
    )

    return (
        filtered_barcodes             = FILTER_BARCODES.filtered_barcodes,
        aggregate_barcodes            = FILTER_BARCODES.aggregate_barcodes,
        nonambient_cell_calls         = FILTER_BARCODES.nonambient_calls,
        barcode_correction_csv        = _MATRIX_COMPUTER.barcode_correction_csv,
        bam_header                    = _MATRIX_COMPUTER.bam_header,
        possorted_genome_bam          = WRITE_POS_BAM.pos_sorted_bam.bam_file,
        possorted_genome_bai_index    = WRITE_POS_BAM.pos_sorted_bam.bai_index_file,
        possorted_genome_csi_index    = WRITE_POS_BAM.pos_sorted_bam.csi_index_file,
        summary                       = MERGE_METRICS.summary,
        barcode_summary               = _MATRIX_COMPUTER.barcode_summary,
        barcode_counts                = _MATRIX_COMPUTER.barcode_counts,
        molecule_info                 = _CELLS_REPORTER.molecule_info,
        raw_gene_bc_matrices_h5       = _MATRIX_COMPUTER.raw_gene_bc_matrices_h5,
        raw_gene_bc_matrices_mex      = _MATRIX_COMPUTER.raw_gene_bc_matrices_mex,
        filtered_gene_bc_matrices_h5  = FILTER_BARCODES.filtered_matrices_h5,
        filtered_gene_bc_matrices_mex = FILTER_BARCODES.filtered_matrices_mex,
        gem_groups                    = [self.gem_well],
        read_shards                   = _MATRIX_COMPUTER.read_shards,
        annotation_files              = _MATRIX_COMPUTER.annotation_files,
        sequencing_metrics            = _MATRIX_COMPUTER.sequencing_metrics,
        per_probe_metrics             = COLLATE_PROBE_METRICS.per_probe_metrics,
        raw_probe_bc_matrix           = COLLATE_PROBE_METRICS.raw_probe_bc_matrix,
        # sliced outputs for multi
        assign_tags                   = _ASSIGN_TAGS.assign_tags_outs,
        multi_pos_sorted_bam          = MULTI_WRITE_PER_SAMPLE_BAM.multi_pos_sorted_bam,
        multi_molecule_info           = MULTI_WRITE_PER_SAMPLE_MOLECULE_INFO.multi_mol_info,
        multi_metrics                 = MULTI_COLLATE_PER_SAMPLE_METRICS.multi_metrics,
        multi_matrices                = MULTI_WRITE_PER_SAMPLE_MATRICES.sample_matrices,
        sample_assignment_metrics     = _ASSIGN_TAGS.assign_tags_outs.sample_assignment_metrics,
        sample_barcodes               = _ASSIGN_TAGS.assign_tags_outs.sample_barcodes,
        # everything below here is needed only for gem well merging
        bc_umi_info                   = _MATRIX_COMPUTER.bc_umi_info,
        per_barcode_metrics           = _MATRIX_COMPUTER.per_barcode_metrics,
        isotype_normalization_factors = FILTER_BARCODES.isotype_normalization_factors,
        per_barcode_metrics_shard     = _MATRIX_COMPUTER.per_barcode_metrics_shard,
        alignments                    = _MATRIX_COMPUTER.alignments,
        read_chunks                   = self.chunks,
        target_set_name               = self.target_set_name,
        slfe_feature_reference        = _MATRIX_COMPUTER.slfe_feature_reference,
        gem_well_alignment_metrics    = _MATRIX_COMPUTER.gem_well_alignment_metrics,
        counts_bc_order               = _MATRIX_COMPUTER.counts_bc_order,
        no_star_alignments            = _MATRIX_COMPUTER.no_star_alignments,
        barcode_index                 = _MATRIX_COMPUTER.barcode_index,
    )
}

#
# @include "_common_stages.mro"
#

stage CELLRANGER_PREFLIGHT(
    in  bool             full_check,
    in  map[]            sample_def,
    in  path             reference_path,
    in  csv              feature_reference,
    in  CellCallingParam recovered_cells,
    in  CellCallingParam force_cells,
    in  int              r1_length,
    in  int              r2_length,
    in  string           targeting_method,
    src py               "stages/common/cellranger_preflight",
) using (
    mem_gb   = 8,
    volatile = strict,
)

stage DISABLE_FEATURE_STAGES(
    in  map[]               sample_def,
    in  bool                disable_multi,
    in  bool                disable_count,
    in  bool                is_pd,
    in  bool                in_disable_targeted,
    in  map<SampleSlfeOuts> sample_outs,
    in  json                multi_graph,
    out bool                disable_crispr,
    out bool                disable_antibody,
    out bool                disable_antigen,
    out bool                disable_multiplexing,
    out bool                disable_targeted,
    out bool                disable_legacy_stages,
    out bool                disable_library_cloupe,
    out bool                disable_gex,
    src py                  "stages/common/disable_feature_stages",
) using (
    volatile = strict,
)

stage DISABLE_SECONDARY_ANALYSIS(
    in  bool is_spatial,
    in  h5   filtered_matrices_h5,
    in  bool no_secondary_analysis,
    in  bool is_visium_hd_main_run  "Boolean indicating if this is being called from a main (not-binning) Visium HD run",
    out bool no_secondary_analysis,
    src py   "stages/common/disable_secondary_analysis",
) using (
    volatile = strict,
)

stage PARSE_TARGET_FEATURES(
    in  map[]    sample_def,
    in  path     reference_path,
    in  json     gene_index,
    in  bool     filter_probes,
    in  bool     no_target_umi_filter,
    in  bool     no_bam,
    in  bool     is_pd,
    out fa       bait_fasta,
    out csv      target_panel,
    out csv      probe_set,
    out csv      target_panel_or_probe_set,
    out csv      target_gene_indices,
    out bool     disable_targeted,
    out bool     disable_target_umi_filter,
    out bool     no_bam,
    out string   target_set_name,
    out string   targeting_method,
    out tps.json target_panel_summary,
    src py       "stages/common/parse_target_features",
) using (
    mem_gb   = 4,
    volatile = strict,
)

#
# @include "_deconvolve_spots.mro"
#

stage DECONVOLVE_SPOTS(
    in  h5   filtered_matrix,
    in  path analysis,
    out path deconvolution,
    src py   "stages/spatial/deconvolve_spots",
) split (
) using (
    volatile = strict,
)

#
# @include "_run_spatial_enrichment.mro"
#

stage RUN_SPATIAL_ENRICHMENT(
    in  h5     filtered_gene_bc_matrices_h5,
    in  csv    tissue_positions,
    in  json   image_scale_factors,
    out pickle chunked_spatial_enrichment_files,
    out csv    spatial_enrichment_csv,
    out json   spatial_enrichment_json,
    src py     "stages/spatial/run_spatial_enrichment",
) split (
    in  pickle weight_matrix_file,
    in  h5     submatrix_path,
    in  pickle feature_def_path,
    in  int    row_start,
    in  int    total_rows,
    in  bool   has_secondary_name,
) using (
    mem_gb   = 6,
    volatile = strict,
)

#
# @include "_common_cloupe_stages.mro"
#

stage CLOUPE_PREPROCESS(
    in  string   pipestance_type,
    in  string   sample_id,
    in  string   sample_desc,
    in  path     analysis,
    in  h5       filtered_gene_bc_matrices_h5,
    in  json     metrics_json,
    in  csv      aggregation_csv,
    in  json     gem_group_index_json,
    in  string[] image_page_names,
    in  file[]   tissue_image_paths,
    in  int      dark_images,
    in  csv      tissue_positions,
    in  txt      fiducial_positions_list,
    in  json     dzi_info,
    in  path[]   dzi_tiles_paths,
    in  json     scale_factors_json,
    in  bool     no_secondary_analysis,
    in  string   barcode_whitelist,
    in  string   hd_slide_name,
    in  json     loupe_map,
    in  string   product_type,
    in  json     cells_per_sample,
    in  json     cells_per_tag,
    in  json     cells_per_protospacer,
    in  csv      spatial_enrichment,
    in  path     spatial_deconvolution_path,
    in  bool     disable_cloupe,
    out cloupe   output_for_cloupe,
    out json     gem_group_index_json,
    src py       "stages/cloupe/cloupe_preprocess",
) split (
) using (
    volatile = strict,
)

#
# @include "_spatial_reporting_stages.mro"
#

stage WEBSUMMARY_ALERTS(
    in  path   loupe_alignment_file,
    in  file[] cytassist_image_paths,
    in  bool   is_visium_hd,
    out bool   slide_id_mismatch,
    src py     "stages/spatial/websummary_alerts",
)

stage SPATIAL_REPORTER(
    in  json[]            summaries,
    in  string            sample_id,
    in  string            sample_desc,
    in  map<ChemistryDef> chemistry_defs,
    in  string            slide_serial_info,
    in  path              reference_path,
    in  path              analysis,
    in  h5                barcode_summary_h5,
    in  csv               filtered_barcodes,
    in  csv               feature_reference,
    in  int[]             gem_groups,
    in  h5                matrix,
    in  json              scalefactors,
    in  jpg               aligned_fiducials,
    in  float             fraction_under_tissue,
    in  png               tissue_hires_image,
    in  png               tissue_lowres_image,
    in  tiff              cytassist_image,
    in  jpg               detected_tissue_image,
    in  jpg               qc_resampled_cyta_img,
    in  jpg               qc_regist_target_img,
    in  csv               tissue_positions,
    in  string            target_set_name,
    in  string            targeting_method,
    in  tps.json          target_panel_summary,
    in  json              antibody_histograms,
    in  json              antibody_treemap,
    in  json              raw_normalized_heatmap,
    in  json              isotype_scatter,
    in  json              gex_fbc_correlation_heatmap,
    in  json              ab_qc_summary,
    in  csv               per_feature_metrics_csv,
    in  string            reorientation_mode,
    in  bool              filter_probes,
    in  bool              include_introns,
    in  string            aligner,
    in  path              loupe_alignment_file,
    in  file[]            tissue_image_paths,
    in  tiff[]            cytassist_image_paths,
    in  h5                v1_filtered_fbm,
    in  json              hd_layout_data_json,
    in  bool              override_id,
    in  bool              slide_id_mismatch,
    in  bool              is_visium_hd,
    out html              web_summary,
    out json              web_summary_json,
    out json              metrics_summary_json,
    out csv               metrics_summary_csv,
    out csv               feature_reference,
    src py                "stages/spatial/spatial_reporter",
) split (
) using (
    volatile = strict,
) retain (
    metrics_summary_json,
)

stage SPATIAL_FOLDER_COLLECTOR(
    in  jpg           aligned_fiducials,
    in  jpg           detected_tissue_image,
    in  json          scalefactors,
    in  json          tissue_transform_json,
    in  png           tissue_hires_image,
    in  png           tissue_lowres_image,
    in  tiff          cytassist_image,
    in  jpg           qc_resampled_cyta_img,
    in  jpg           qc_regist_target_img,
    in  jpg           aligned_tissue_image,
    in  csv           tissue_positions,
    in  csv           spatial_enrichment,
    in  csv           barcode_fluorescence_intensity,
    in  bool          is_visium_hd,
    out SpatialFolder spatial,
    src py            "stages/spatial/spatial_folder_collector",
) using (
    volatile = strict,
)

stage DISABLE_DECONVOLUTION(
    in  bool disable_gex,
    in  bool is_visium_hd,
    out bool disable_deconvolution,
    src py   "stages/spatial/disable_deconvolution",
)

#
# @include "_spatial_stages.mro"
#

stage BIN_COUNT_MATRIX(
    in  int        bin_scale,
    in  h5         hd_feature_slice,
    in  csf[]      counts,
    in  json       barcodes_under_tissue,
    in  bi.bincode barcode_index,
    in  json       scalefactors,
    out csf        binned_counts,
    out bi.bincode binned_barcode_index,
    out json       filtered_bin_barcodes,
    out json       binned_scalefactors,
    out csv        binned_tissue_positions,
    out parquet    binned_tissue_positions_parquet,
    src comp       "spatial martian bin_count_matrix",
) using (
    mem_gb   = 12,
    volatile = strict,
)

stage COMPUTE_BIN_METRICS(
    in  h5   filtered_matrix_h5,
    in  h5   hd_feature_slice,
    in  int  bin_scale,
    in  json metrics_json,
    out json summary,
    src comp "spatial martian compute_bin_metrics",
) split (
) using (
    volatile = strict,
)

stage COMPUTE_SUBSAMPLED_BIN_METRICS(
    in  h5  molecule_info,
    in  int bin_scale,
    out csv subsampled_metrics,
    src comp "spatial martian compute_subsampled_bin_metrics",
) using (
    mem_gb   = 6,
    volatile = strict,
)

stage WRITE_BINNED_H5_MATRIX(
    in  int               gem_well,
    in  csf[]             counts,
    in  frf.bincode       feature_reference,
    in  map<ChemistryDef> chemistry_defs,
    in  string            sample_id,
    in  bi.bincode        barcode_index,
    out h5                matrix,
    src comp              "spatial martian write_binned_h5_matrix",
) using (
    mem_gb   = 5,
    volatile = strict,
)

stage SETUP_BINNING(
    in  string            slide_name,
    in  bool              no_secondary_analysis,
    in  int[]             scales,
    in  int               custom_bin_size,
    out map<BinLevelInfo> bin_infos,
    out bool              disable_binning,
    src comp              "spatial martian setup_binning",
) using (
    mem_gb   = 2,
    volatile = strict,
)

stage CREATE_HD_FEATURE_SLICE(
    in  string           sample_id,
    in  string           sample_desc,
    in  h5               raw_matrix_h5,
    in  json             hd_layout_data_json,
    in  string           visium_hd_slide_name,
    in  h5               barcode_summary_h5,
    in  UmiRegOutsSubset umi_registration_outs,
    out h5               hd_feature_slice,
    src comp             "spatial martian create_hd_feature_slice",
) split (
) using (
    volatile = strict,
)

stage MERGE_BIN_METRICS(
    in  json[]    summaries,
    in  map<json> bin_summaries,
    out json      summary,
    src comp      "spatial martian merge_bin_metrics",
) using (
    volatile = strict,
)

stage GENERATE_HD_WEBSUMMARY_CS(
    in  json      sd_web_summary_json,
    in  json      end_to_end_alignment_data,
    in  map<json> bin_level_metrics,
    in  json      cluster_plot,
    in  json      saturation_plots,
    out html      web_summary,
    src comp      "spatial martian generate_hd_websummary_cs",
) using (
    volatile = strict,
)

#
# @include "_spatial_hd_binning.mro"
#

stage PICK_SPATIAL_COUNTER_OUTS(
    in  h5          filtered_feature_bc_matrix_h5_in,
    in  path        filtered_feature_bc_matrix_mex_in,
    in  h5          raw_feature_bc_matrix_h5_in,
    in  path        raw_feature_bc_matrix_mex_in,
    in  h5          raw_probe_bc_matrix_h5_in,
    in  bool        is_visium_hd,
    in  map<cloupe> cloupe_files,
    in  int         custom_bin_size,
    in  html        sd_web_summary,
    in  html        hd_web_summary,
    out h5          filtered_feature_bc_matrix_h5_out,
    out path        filtered_feature_bc_matrix_mex_out,
    out h5          raw_feature_bc_matrix_h5_out,
    out path        raw_feature_bc_matrix_mex_out,
    out h5          raw_probe_bc_matrix_h5_out,
    out cloupe      cloupe_008um,
    out cloupe      cloupe_custom,
    out html        web_summary,
    src py          "stages/spatial/pick_spatial_counter_outs",
) using (
    volatile = strict,
)

stage UPDATE_HD_FEATURE_SLICE_H5(
    in  h5        filtered_matrix_h5,
    in  h5        hd_feature_slice_h5_in,
    in  map<path> binned_analysis,
    in  png       cytassist_image_on_spots,
    in  png       microscope_image_on_spots,
    out h5        hd_feature_slice_h5_out    "HD Feature Slice"  "hd_feature_slice.h5",
    src py        "stages/spatial/update_hd_feature_slice_h5",
) split (
) using (
    volatile = strict,
)

# Generate plots for Image Alignment QC in HD
# The key difference compared to SD is that we use the "UMI Image"
# in addition to the cytassist and microscope image for alignment QC
stage PROCESS_HD_ALIGNMENT(
    in  h5   hd_feature_slice_h5,
    in  json fiducial_transform,
    in  json tissue_registration_transform,
    in  json scalefactors,
    in  tiff cytassist_image,
    in  tiff microscope_image,
    out png  cytassist_image_on_spots,
    out png  umi_cytassist_checkerboard,
    out png  log_umi_image,
    out png  microscope_image_on_spots,
    out png  umi_microscope_checkerboard,
    out h5   hd_feature_slice_h5_out,
    src py   "stages/spatial/process_hd_alignment",
) using (
    mem_gb   = 2,
    vmem_gb  = 8,
    volatile = strict,
)

stage WRITE_BINNED_MATRICES(
    in  string            sample_id,
    in  h5                raw_matrix_h5,
    in  map<ChemistryDef> chemistry_defs,
    in  json              filtered_bin_barcodes,
    out h5                filtered_matrices_h5,
    out path              filtered_matrices_mex,
    out path              raw_matrices_mex,
    src py                "stages/spatial/write_binned_matrices",
) split (
) using (
    volatile = strict,
)

# Produce a UMI image at the given binning scale
stage CREATE_TOTAL_UMI_IMAGE(
    in  h5   hd_feature_slice_h5,
    in  int  binning_scale,
    out png  umi_image,
    out png  log_umi_image,
    out tiff log_umi_image_3k,
    out tiff umi_image_3k,
    src py   "stages/spatial/create_total_umi_image",
) using (
    mem_gb   = 3,
    vmem_gb  = 9,
    volatile = strict,
)

stage RECEIVE_SUBSAMPLED_METRICS(
    in  csv  subsampled_metrics,
    out json saturation_plots,
    src py   "stages/spatial/receive_subsampled_metrics",
) using (
    volatile = strict,
)

stage PICK_SATURATION_PLOT(
    in  map<json> saturation_plots,
    out json      saturation_plots_picked,
    src py        "stages/spatial/pick_saturation_plot",
) using (
    volatile = strict,
)

stage CREATE_HD_WEBSUMMARY_IMAGE(
    in  png   tissue_hires_image,
    in  json  scalefactors,
    in  int   dark_images,
    out jpg   websummary_tissue_image,
    out float websummary_tissue_image_scale,
    src py    "stages/spatial/create_hd_websummary_image",
) using (
    volatile = strict,
)

stage BUILD_HD_END_TO_END_ALIGNMENT(
    in  h5    hd_feature_slice_h5,
    in  jpg   websummary_tissue_image,
    in  float websummary_tissue_image_scale,
    out json  end_to_end_alignment_data,
    src py    "stages/spatial/build_hd_end_to_end_alignment",
) using (
    vmem_gb  = 8,
    volatile = strict,
)

stage BUILD_HD_CLUSTERING_PLOT(
    in  h5        hd_feature_slice,
    in  jpg       websummary_tissue_image,
    in  float     websummary_tissue_image_scale,
    in  map<path> analysis_h5,
    out json      cluster_plot,
    src py        "stages/spatial/build_hd_clustering_plot",
) using (
    mem_gb   = 10,
    volatile = strict,
)

stage PICK_PROBE_BC_MATRIX(
    in  h5  raw_probe_bc_matrix_base_bin,
    in  int bin_scale,
    out h5  raw_probe_bc_matrix,
    src py  "stages/spatial/pick_probe_bc_matrix",
)

pipeline _COMPUTE_BINNED_OUTPUTS(
    in  BinLevelInfo      bin_info,
    in  h5                molecule_info,
    in  string            visium_hd_slide_name,
    in  h5                hd_feature_slice_h5,
    in  csf[]             counts_bc_order,
    in  map<ChemistryDef> chemistry_defs,
    in  string            sample_id,
    in  h5                raw_probe_bc_matrix_base_bin,
    in  string            sample_desc,
    in  frf.bincode       slfe_feature_reference,
    in  json              barcodes_under_tissue,
    in  file[]            tissue_image_paths,
    in  int               dark_images,
    in  txt               fiducial_positions_list,
    in  json              dzi_info,
    in  path[]            dzi_tiles_paths,
    in  json              scalefactors,
    in  bool              is_pd,
    in  string[]          image_page_names,
    in  SpatialFolder     spatial,
    in  json              metrics_json,
    in  bi.bincode        barcode_index,
    out BinnedOutputs     binned_outputs,
    out json              summary,
)
{
    call BIN_COUNT_MATRIX(
        bin_scale             = self.bin_info.scale,
        counts                = self.counts_bc_order,
        barcodes_under_tissue = self.barcodes_under_tissue,
        scalefactors          = self.scalefactors,
        hd_feature_slice      = self.hd_feature_slice_h5,
        barcode_index         = self.barcode_index,
    )

    call PICK_PROBE_BC_MATRIX(
        bin_scale                    = self.bin_info.scale,
        raw_probe_bc_matrix_base_bin = self.raw_probe_bc_matrix_base_bin,
    )

    call COMPUTE_SUBSAMPLED_BIN_METRICS(
        molecule_info = self.molecule_info,
        bin_scale     = self.bin_info.scale,
    )

    call RECEIVE_SUBSAMPLED_METRICS(
        subsampled_metrics = COMPUTE_SUBSAMPLED_BIN_METRICS.subsampled_metrics,
    )

    call WRITE_BINNED_H5_MATRIX(
        gem_well          = 1,
        counts            = [BIN_COUNT_MATRIX.binned_counts],
        feature_reference = self.slfe_feature_reference,
        chemistry_defs    = self.chemistry_defs,
        sample_id         = self.sample_id,
        barcode_index     = BIN_COUNT_MATRIX.binned_barcode_index,
    )

    call WRITE_BINNED_MATRICES(
        sample_id             = self.sample_id,
        raw_matrix_h5         = WRITE_BINNED_H5_MATRIX.matrix,
        chemistry_defs        = self.chemistry_defs,
        filtered_bin_barcodes = BIN_COUNT_MATRIX.filtered_bin_barcodes,
    )

    call COMPUTE_BIN_METRICS(
        bin_scale          = self.bin_info.scale,
        hd_feature_slice   = self.hd_feature_slice_h5,
        filtered_matrix_h5 = WRITE_BINNED_MATRICES.filtered_matrices_h5,
        metrics_json       = self.metrics_json,
    )

    call DISABLE_SECONDARY_ANALYSIS(
        is_spatial            = true,
        is_visium_hd_main_run = false,
        filtered_matrices_h5  = WRITE_BINNED_MATRICES.filtered_matrices_h5,
        no_secondary_analysis = self.bin_info.no_secondary_analysis,
    )

    call SC_RNA_ANALYZER as SPATIAL_BINNED_RNA_ANALYZER(
        aggregate_barcodes = null,
        analyzer_inputs    = {
            aggr_library_info:          null,
            cbc_alpha:                  null,
            cbc_knn:                    null,
            cbc_realign_panorama:       null,
            cbc_sigma:                  null,
            chemistry_batch_correction: false,
            exclude_genes:              null,
            filtered_matrices_h5:       WRITE_BINNED_MATRICES.filtered_matrices_h5,
            force_cells:                null,
            graphclust_neighbors:       null,
            graphclust_resolution:      0.3,
            is_pd:                      self.is_pd,
            is_spatial:                 true,
            is_visium_hd:               true,
            max_clusters:               null,
            molecule_info:              null,
            neighbor_a:                 null,
            neighbor_b:                 null,
            no_secondary_analysis:      DISABLE_SECONDARY_ANALYSIS.no_secondary_analysis,
            num_analysis_bcs:           null,
            num_pca_bcs:                null,
            num_pca_genes:              null,
            num_principal_comps:        null,
            random_seed:                null,
            skip_multigenome_analysis:  true,
            tsne_input_pcs:             null,
            tsne_max_dims:              null,
            tsne_max_iter:              null,
            tsne_mom_switch_iter:       null,
            tsne_perplexity:            null,
            tsne_stop_lying_iter:       null,
            tsne_theta:                 null,
            umap_implementation:        "original",
            umap_input_pcs:             null,
            umap_max_dims:              null,
            umap_metric:                null,
            umap_min_dist:              null,
            umap_n_neighbors:           null,
            use_bcs:                    null,
            use_genes:                  null,
        },
    )

    call CLOUPE_PREPROCESS(
        pipestance_type              = "SPATIAL_RNA_COUNTER_PD",
        sample_id                    = self.sample_id,
        sample_desc                  = self.sample_desc,
        analysis                     = SPATIAL_BINNED_RNA_ANALYZER.common_analyzer.analysis,
        filtered_gene_bc_matrices_h5 = WRITE_BINNED_MATRICES.filtered_matrices_h5,
        metrics_json                 = null,
        aggregation_csv              = null,
        gem_group_index_json         = null,
        image_page_names             = self.image_page_names,
        tissue_image_paths           = self.tissue_image_paths,
        dark_images                  = self.dark_images,
        tissue_positions             = BIN_COUNT_MATRIX.binned_tissue_positions,
        fiducial_positions_list      = self.fiducial_positions_list,
        dzi_info                     = self.dzi_info,
        dzi_tiles_paths              = self.dzi_tiles_paths,
        scale_factors_json           = BIN_COUNT_MATRIX.binned_scalefactors,
        no_secondary_analysis        = DISABLE_SECONDARY_ANALYSIS.no_secondary_analysis,
        barcode_whitelist            = null,
        hd_slide_name                = self.visium_hd_slide_name,
        loupe_map                    = null,
        product_type                 = "sp",
        cells_per_tag                = null,
        cells_per_sample             = null,
        cells_per_protospacer        = null,
        spatial_enrichment           = null,
        spatial_deconvolution_path   = null,
        disable_cloupe               = self.bin_info.disable_cloupe,
    )

    call CREATE_TOTAL_UMI_IMAGE(
        binning_scale       = self.bin_info.scale,
        hd_feature_slice_h5 = self.hd_feature_slice_h5,
    )

    return (
        binned_outputs = {
            analysis:                      SPATIAL_BINNED_RNA_ANALYZER.common_analyzer.analysis,
            analysis_csv:                  SPATIAL_BINNED_RNA_ANALYZER.common_analyzer.analysis_csv,
            cloupe:                        CLOUPE_PREPROCESS.output_for_cloupe,
            filtered_feature_bc_matrix:    WRITE_BINNED_MATRICES.filtered_matrices_mex,
            filtered_feature_bc_matrix_h5: WRITE_BINNED_MATRICES.filtered_matrices_h5,
            raw_feature_bc_matrix:         WRITE_BINNED_MATRICES.raw_matrices_mex,
            raw_feature_bc_matrix_h5:      WRITE_BINNED_H5_MATRIX.matrix,
            raw_probe_bc_matrix:           PICK_PROBE_BC_MATRIX.raw_probe_bc_matrix,
            saturation_plots:              RECEIVE_SUBSAMPLED_METRICS.saturation_plots,
            spatial: {
                aligned_fiducials:              self.spatial.aligned_fiducials,
                aligned_tissue_image:           self.spatial.aligned_tissue_image,
                barcode_fluorescence_intensity: null,
                cytassist_image:                self.spatial.cytassist_image,
                detected_tissue_image:          self.spatial.detected_tissue_image,
                scalefactors_json:              BIN_COUNT_MATRIX.binned_scalefactors,
                spatial_enrichment:             null,
                tissue_hires_image:             self.spatial.tissue_hires_image,
                tissue_lowres_image:            self.spatial.tissue_lowres_image,
                tissue_positions:               null,
                tissue_positions_parquet:       BIN_COUNT_MATRIX.binned_tissue_positions_parquet,
                tissue_transform_json:          null,
            },
            subsampling_metrics:           COMPUTE_SUBSAMPLED_BIN_METRICS.subsampled_metrics,
            umi_images:                    CREATE_TOTAL_UMI_IMAGE,
        },
        summary        = COMPUTE_BIN_METRICS.summary,
    )
}

pipeline _BIN_HD_DATA(
    in  string               visium_hd_slide_name,
    in  json                 hd_layout_data_json,
    in  csf[]                counts_bc_order,
    in  map<ChemistryDef>    chemistry_defs,
    in  string               sample_id,
    in  string               sample_desc,
    in  frf.bincode          slfe_feature_reference,
    in  json                 barcodes_under_tissue,
    in  file[]               tissue_image_paths,
    in  int                  dark_images,
    in  txt                  fiducial_positions_list,
    in  json                 dzi_info,
    in  path[]               dzi_tiles_paths,
    in  json                 scalefactors,
    in  string[]             image_page_names,
    in  h5                   filtered_matrix_h5,
    in  h5                   raw_matrix_h5,
    in  h5                   molecule_info,
    in  h5                   barcode_summary_h5,
    in  json                 tissue_registration_transform,
    in  json                 fiducial_transform,
    in  tiff                 cytassist_image,
    in  bool                 is_pd,
    in  tiff                 registration_target_image,
    in  map<BinLevelInfo>    bin_infos,
    in  UmiRegOutsSubset     umi_registration_outs,
    in  SpatialFolder        spatial,
    in  json                 metrics_json,
    in  h5                   raw_probe_bc_matrix_base_bin,
    in  bi.bincode           barcode_index,
    out map<BinnedOutputs>   binned_outputs,
    out map<json>            bin_level_metrics,
    out json                 summary,
    out h5                   hd_feature_slice_h5,
    out PROCESS_HD_ALIGNMENT alignment_qc_outs,
)
{
    call CREATE_HD_FEATURE_SLICE(
        * = self,
    )

    call PROCESS_HD_ALIGNMENT(
        hd_feature_slice_h5           = CREATE_HD_FEATURE_SLICE.hd_feature_slice,
        fiducial_transform            = self.fiducial_transform,
        tissue_registration_transform = self.tissue_registration_transform,
        scalefactors                  = self.scalefactors,
        cytassist_image               = self.cytassist_image,
        microscope_image              = self.registration_target_image,
    )

    map call _COMPUTE_BINNED_OUTPUTS(
        hd_feature_slice_h5 = PROCESS_HD_ALIGNMENT.hd_feature_slice_h5_out,
        bin_info            = split self.bin_infos,
        *                   = self,
    )

    call UPDATE_HD_FEATURE_SLICE_H5(
        filtered_matrix_h5        = self.filtered_matrix_h5,
        hd_feature_slice_h5_in    = PROCESS_HD_ALIGNMENT.hd_feature_slice_h5_out,
        binned_analysis           = _COMPUTE_BINNED_OUTPUTS.binned_outputs.analysis,
        cytassist_image_on_spots  = PROCESS_HD_ALIGNMENT.cytassist_image_on_spots,
        microscope_image_on_spots = PROCESS_HD_ALIGNMENT.microscope_image_on_spots,
    )

    call MERGE_BIN_METRICS(
        summaries     = [],
        bin_summaries = _COMPUTE_BINNED_OUTPUTS.summary,
    )

    return (
        binned_outputs      = _COMPUTE_BINNED_OUTPUTS.binned_outputs,
        summary             = MERGE_BIN_METRICS.summary,
        hd_feature_slice_h5 = UPDATE_HD_FEATURE_SLICE_H5.hd_feature_slice_h5_out,
        alignment_qc_outs   = PROCESS_HD_ALIGNMENT,
        bin_level_metrics   = _COMPUTE_BINNED_OUTPUTS.summary,
    )
}

pipeline HD_WEBSUMMARY_BUILDER(
    in  json      sd_web_summary_json,
    in  map<json> bin_level_metrics,
    in  map<path> analysis_h5,
    in  map<json> saturation_plots,
    in  h5        hd_feature_slice,
    in  json      scalefactors,
    in  png       tissue_hires_image,
    in  int       dark_images,
    out html      web_summary,
)
{
    call PICK_SATURATION_PLOT(
        * = self,
    )

    call CREATE_HD_WEBSUMMARY_IMAGE(
        * = self,
    )

    call BUILD_HD_END_TO_END_ALIGNMENT(
        hd_feature_slice_h5 = self.hd_feature_slice,
        *                   = CREATE_HD_WEBSUMMARY_IMAGE,
    )

    call BUILD_HD_CLUSTERING_PLOT(
        hd_feature_slice              = self.hd_feature_slice,
        websummary_tissue_image       = CREATE_HD_WEBSUMMARY_IMAGE.websummary_tissue_image,
        websummary_tissue_image_scale = CREATE_HD_WEBSUMMARY_IMAGE.websummary_tissue_image_scale,
        analysis_h5                   = self.analysis_h5,
    )

    call GENERATE_HD_WEBSUMMARY_CS(
        sd_web_summary_json       = self.sd_web_summary_json,
        end_to_end_alignment_data = BUILD_HD_END_TO_END_ALIGNMENT.end_to_end_alignment_data,
        bin_level_metrics         = self.bin_level_metrics,
        cluster_plot              = BUILD_HD_CLUSTERING_PLOT.cluster_plot,
        saturation_plots          = PICK_SATURATION_PLOT.saturation_plots_picked,
    )

    return (
        web_summary = GENERATE_HD_WEBSUMMARY_CS.web_summary,
    )
}

pipeline BIN_HD_DATA(
    in  string               visium_hd_slide_name,
    in  json                 hd_layout_data_json,
    in  csf[]                counts_bc_order,
    in  map<ChemistryDef>    chemistry_defs,
    in  string               sample_id,
    in  string               sample_desc,
    in  frf.bincode          slfe_feature_reference,
    in  json                 barcodes_under_tissue,
    in  bool                 no_secondary_analysis,
    in  file[]               tissue_image_paths,
    in  int                  dark_images,
    in  txt                  fiducial_positions_list,
    in  json                 dzi_info,
    # NOTE: scales are a multiple of the pitch
    in  int[]                scales,
    in  path[]               dzi_tiles_paths,
    in  json                 scalefactors,
    in  string[]             image_page_names,
    in  h5                   filtered_matrix_h5,
    in  h5                   raw_matrix_h5,
    in  h5                   barcode_summary_h5,
    in  h5                   molecule_info,
    in  json                 tissue_registration_transform,
    in  json                 fiducial_transform,
    in  tiff                 cytassist_image,
    in  tiff                 registration_target_image,
    in  UmiRegOutsSubset     umi_registration_outs,
    in  SpatialFolder        spatial,
    in  int                  custom_bin_size,
    in  json                 metrics_json,
    in  h5                   raw_probe_bc_matrix_base_bin,
    in  bool                 is_pd,
    in  bi.bincode           barcode_index,
    out map<BinnedOutputs>   binned_outputs,
    out bool                 disable_binning,
    out map<int>             binning_scales,
    out map<BinLevelInfo>    bin_infos,
    out json                 summary,
    out h5                   hd_feature_slice_h5,
    out PROCESS_HD_ALIGNMENT alignment_qc_outs,
    out map<json>            bin_level_metrics,
)
{
    call SETUP_BINNING(
        slide_name            = self.visium_hd_slide_name,
        no_secondary_analysis = self.no_secondary_analysis,
        # NOTE: scales are a multiple of the pitch
        scales                = self.scales,
        custom_bin_size       = self.custom_bin_size,
    )

    call _BIN_HD_DATA(
        bin_infos = SETUP_BINNING.bin_infos,
        *         = self,
    ) using (
        disabled = SETUP_BINNING.disable_binning,
    )

    return (
        binned_outputs      = _BIN_HD_DATA.binned_outputs,
        disable_binning     = SETUP_BINNING.disable_binning,
        binning_scales      = SETUP_BINNING.bin_infos.scale,
        bin_infos           = SETUP_BINNING.bin_infos,
        summary             = _BIN_HD_DATA.summary,
        hd_feature_slice_h5 = _BIN_HD_DATA.hd_feature_slice_h5,
        alignment_qc_outs   = _BIN_HD_DATA.alignment_qc_outs,
        bin_level_metrics   = _BIN_HD_DATA.bin_level_metrics,
    )
}

#
# @include "_sc_rna_targeted_analyzer_stages.mro"
#

stage CALCULATE_TARGETED_METRICS(
    in  h5       molecule_info,
    in  h5       filtered_gene_bc_matrices,
    in  json     basic_counter_summary,
    in  tps.json target_panel_summary,
    in  bool     is_spatial,
    out json     summary,
    out csv      per_feature_metrics_csv,
    src py       "stages/targeted/calculate_targeted_metrics",
) split (
) using (
    volatile = strict,
)

stage DISABLE_TARGETED_STAGES(
    in  csv  probe_set,
    in  bool is_visium_hd,
    out bool disable_targeted_gdna,
    out bool disable_sampling_stages,
    src py   "stages/targeted/disable_targeted_stages",
) using (
    volatile = strict,
)

stage GET_GDNA_PLOT(
    in  json gdna_plot_sufficient_stats,
    out json summary,
    src py   "stages/targeted/get_gdna_plot",
) using (
    volatile = strict,
)

#
# @include "_targeted_analyzer.mro"
#

pipeline _RUN_GDNA_ANALYSIS(
    in  h5   molecule_info,
    in  path reference_path,
    in  csv  probe_set,
    out json gdna_summary,
)
{
    call GET_GDNA_METRICS(
        molecule_info  = self.molecule_info,
        reference_path = self.reference_path,
        probe_set      = self.probe_set,
    )

    call GET_GDNA_PLOT(
        gdna_plot_sufficient_stats = GET_GDNA_METRICS.gdna_plot_sufficient_stats,
    )

    call MERGE_METRICS(
        summaries = [
            GET_GDNA_METRICS.summary,
            GET_GDNA_PLOT.summary,
        ],
    )

    return (
        gdna_summary = MERGE_METRICS.summary,
    )
}

pipeline _TARGETED_ANALYZER(
    in  h5       molecule_info,
    in  h5       filtered_gene_bc_matrices,
    in  csv      filtered_barcodes,
    in  json     basic_counter_summary,
    in  path     reference_path,
    in  csv      probe_set,
    in  bool     is_visium_hd,
    in  tps.json target_panel_summary,
    in  bool     is_spatial,
    out json     targeted_analysis_metrics,
    out csv      per_feature_metrics_csv,
)
{
    call DISABLE_TARGETED_STAGES(
        * = self,
    )

    call _RUN_GDNA_ANALYSIS(
        molecule_info  = self.molecule_info,
        reference_path = self.reference_path,
        probe_set      = self.probe_set,
    ) using (
        disabled = DISABLE_TARGETED_STAGES.disable_targeted_gdna,
    )

    call CALCULATE_TARGETED_METRICS(
        molecule_info             = self.molecule_info,
        filtered_gene_bc_matrices = self.filtered_gene_bc_matrices,
        basic_counter_summary     = self.basic_counter_summary,
        target_panel_summary      = self.target_panel_summary,
        is_spatial                = self.is_spatial,
    )

    call SUBSAMPLE_READS as SUBSAMPLE_ON_TARGET_READS(
        molecule_info     = self.molecule_info,
        filtered_barcodes = self.filtered_barcodes,
        target_mode       = "ontarget",
    ) using (
        disabled = DISABLE_TARGETED_STAGES.disable_sampling_stages,
    )

    call SUBSAMPLE_READS as SUBSAMPLE_OFF_TARGET_READS(
        molecule_info     = self.molecule_info,
        filtered_barcodes = self.filtered_barcodes,
        target_mode       = "offtarget",
    ) using (
        disabled = DISABLE_TARGETED_STAGES.disable_sampling_stages,
    )

    call MERGE_METRICS(
        summaries = [
            CALCULATE_TARGETED_METRICS.summary,
            SUBSAMPLE_ON_TARGET_READS.summary,
            SUBSAMPLE_OFF_TARGET_READS.summary,
            _RUN_GDNA_ANALYSIS.gdna_summary,
        ],
    )

    return (
        targeted_analysis_metrics = MERGE_METRICS.summary,
        per_feature_metrics_csv   = CALCULATE_TARGETED_METRICS.per_feature_metrics_csv,
    )
}

#
# @include "spatial_rna_counter.mro"
#

pipeline SPATIAL_RNA_COUNTER(
    in  string               sample_id,
    in  map[]                sample_def,
    in  string               slide_serial_capture_area,
    in  map[]                chunks,
    in  map<ChemistryDef>    chemistry_defs,
    in  path                 reference_path,
    in  int                  recovered_cells,
    in  int                  force_cells,
    in  float                subsample_rate,
    in  int                  initial_reads,
    in  string               sample_desc,
    in  int                  r1_length                       "Trim input R1 to this length (optional)",
    in  int                  r2_length                       "Trim input R2 to this length (optional)",
    in  int                  trim_polya_min_score,
    in  int                  trim_tso_min_score,
    in  int                  min_reads_to_report_bc,
    in  bool                 no_bam,
    in  bool                 no_secondary_analysis,
    in  bool                 filter_probes,
    in  bool                 no_target_umi_filter,
    in  string               aligner,
    in  bool                 is_pd,
    in  json                 barcodes_under_tissue,
    in  float                fraction_under_tissue,
    in  json                 alignment_metrics,
    in  jpg                  aligned_fiducials,
    in  png                  tissue_hires_img,
    in  png                  tissue_lowres_img,
    in  tiff                 cytassist_image,
    in  jpg                  detected_tissue_img,
    in  jpg                  qc_resampled_cyta_img,
    in  jpg                  qc_regist_target_img,
    in  jpg                  aligned_tissue_img,
    in  csv                  tissue_positions,
    in  json                 image_scale_factors,
    in  json                 tissue_transform_json,
    in  json                 tissue_registration_metrics,
    in  csv                  barcode_fluorescence_intensity,
    in  csv                  feature_reference,
    in  bool                 is_antibody_only,
    in  string               reorientation_mode,
    in  bool                 include_introns,
    in  path                 loupe_alignment_file,
    in  file[]               cytassist_image_paths,
    in  file[]               tissue_image_paths,
    in  FeatureConfig        feature_config,
    in  h5                   v1_filtered_fbm,
    in  json                 fraction_bc_outside_image,
    in  bool                 is_visium_hd,
    in  string               visium_hd_slide_name,
    in  bool                 override_id,
    in  json                 hd_layout_data_json,
    in  int                  dark_images,
    in  txt                  fiducial_positions_list,
    in  json                 dzi_info,
    # NOTE: scales are a multiple of the pitch
    in  int[]                scales,
    in  path[]               dzi_tiles_paths,
    in  json                 scalefactors,
    in  string[]             image_page_names,
    in  json                 tissue_registration_transform,
    in  json                 fiducial_transform,
    in  tiff                 registration_target_image,
    in  UmiRegOutsSubset     umi_registration_outs,
    in  int                  custom_bin_size,
    out json                 gene_index,
    out path                 bam_header,
    out bam                  possorted_genome_bam,
    out bam.bai              possorted_genome_bai_index,
    out bam.csi              possorted_genome_csi_index,
    out SpatialFolder        spatial,
    out json                 metrics_summary_json,
    out csv                  metrics_summary_csv,
    out csv                  feature_reference,
    out html                 web_summary,
    out json                 web_summary_json,
    out h5                   barcode_summary,
    out h5                   molecule_info,
    out h5                   raw_gene_bc_matrices_h5,
    out path                 raw_gene_bc_matrices_mex,
    out h5                   filtered_gene_bc_matrices_h5,
    out path                 filtered_gene_bc_matrices_mex,
    out path                 analysis,
    out path                 analysis_csv,
    out ReadShards           read_shards,
    out int[]                gem_groups,
    out csv                  filtered_barcodes,
    out csv                  barcode_correction_csv,
    out AnnotationFiles      annotation_files,
    out tbcc.bincode         barcode_counts,
    out asf[]                alignments,
    out map[]                read_chunks,
    out csv                  per_barcode_metrics,
    out bool                 disable_targeted,
    out csv                  target_panel,
    out csv                  probe_set,
    out csv                  target_panel_or_probe_set,
    out string               target_set_name,
    out string               targeting_method,
    out csv                  per_feature_metrics_csv,
    out csv                  per_probe_metrics,
    out csv                  isotype_normalization_factors,
    out h5                   raw_probe_bc_matrix,
    out fa                   bait_fasta,
    out csv                  spatial_enrichment,
    out h5                   clustering_h5,
    out path                 deconvolution,
    out frf.bincode          slfe_feature_reference,
    out json                 raw_normalized_heatmap,
    out json                 isotype_scatter,
    out json                 gex_fbc_correlation_heatmap,
    # Shard files of feature x barcode counts sorted by barcode
    out csf[]                counts_bc_order,
    out bool                 no_star_alignments,
    out bi.bincode           barcode_index,
    out map<BinnedOutputsCs> binned_outputs                  "Outputs at each bin level",
    out map<BinnedOutputs>   base_binned_outputs,
    out html                 hd_web_summary,
    out h5                   hd_feature_slice,
    out bool                 disable_binning,
    out map<BinLevelInfo>    bin_infos,
    out PROCESS_HD_ALIGNMENT alignment_qc_outs,
    out json                 summary,
)
{
    call WRITE_GENE_INDEX(
        reference_path = self.reference_path,
    )

    call DISABLE_FEATURE_STAGES(
        sample_def          = self.sample_def,
        disable_multi       = true,
        disable_count       = true,
        in_disable_targeted = null,
        is_pd               = true,
        sample_outs         = null,
        multi_graph         = null,
    )

    call DISABLE_DECONVOLUTION(
        disable_gex  = DISABLE_FEATURE_STAGES.disable_gex,
        is_visium_hd = self.is_visium_hd,
    )

    call PARSE_TARGET_FEATURES(
        reference_path       = self.reference_path,
        gene_index           = WRITE_GENE_INDEX.gene_index,
        sample_def           = self.sample_def,
        filter_probes        = self.filter_probes,
        no_target_umi_filter = self.no_target_umi_filter,
        is_pd                = self.is_pd,
        no_bam               = self.no_bam,
    )

    call _BASIC_SC_RNA_COUNTER as _BASIC_SPATIAL_RNA_COUNTER(
        gem_well                  = 1,
        sample_id                 = self.sample_id,
        chemistry_defs            = self.chemistry_defs,
        is_antibody_only          = self.is_antibody_only,
        reference_path            = self.reference_path,
        slide_serial_capture_area = self.slide_serial_capture_area,
        cell_calling_config       = {
            cell_barcodes:                        self.barcodes_under_tissue,
            disable_ab_aggregate_detection:       true,
            disable_high_occupancy_gem_detection: false,
            emptydrops_minimum_umis:              null,
            force_cells: {
                per_gem_well: self.force_cells,
                per_sample:   null,
            },
            global_minimum_umis:                  null,
            max_mito_percent:                     null,
            override_library_types:               null,
            override_mode:                        null,
            recovered_cells: {
                per_gem_well: self.recovered_cells,
                per_sample:   null,
            },
        },
        libraries_to_translate    = [],
        is_pd                     = self.is_pd,
        chunks                    = self.chunks,
        subsample_rate            = self.subsample_rate,
        initial_reads             = self.initial_reads,
        r1_length                 = self.r1_length,
        r2_length                 = self.r2_length,
        trim_polya_min_score      = self.trim_polya_min_score,
        trim_tso_min_score        = self.trim_tso_min_score,
        min_reads_to_report_bc    = self.min_reads_to_report_bc,
        feature_reference         = self.feature_reference,
        target_features           = PARSE_TARGET_FEATURES.target_gene_indices,
        target_set                = PARSE_TARGET_FEATURES.target_panel_or_probe_set,
        target_set_name           = PARSE_TARGET_FEATURES.target_set_name,
        target_panel_summary      = PARSE_TARGET_FEATURES.target_panel_summary,
        include_exons             = true,
        include_introns           = self.include_introns,
        filter_probes             = self.filter_probes,
        aligner                   = self.aligner,
        disable_target_umi_filter = PARSE_TARGET_FEATURES.disable_target_umi_filter,
        multi_config_sha          = null,
        no_bam                    = PARSE_TARGET_FEATURES.no_bam,
        force_sample_barcodes     = {
            cells_per_tag:        null,
            non_singlet_barcodes: null,
            sample_barcodes:      null,
        },
        disable_multi             = true,
        multi_graph               = null,
        is_spatial                = true,
        min_assignment_confidence = null,
        feature_config            = self.feature_config,
        v1_filtered_fbm           = self.v1_filtered_fbm,
        is_visium_hd              = self.is_visium_hd,
    )

    call RUN_SPATIAL_ENRICHMENT(
        filtered_gene_bc_matrices_h5 = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        tissue_positions             = self.tissue_positions,
        image_scale_factors          = self.image_scale_factors,
    )

    call DISABLE_SECONDARY_ANALYSIS(
        is_spatial            = true,
        is_visium_hd_main_run = self.is_visium_hd,
        filtered_matrices_h5  = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        no_secondary_analysis = self.no_secondary_analysis,
    )

    call SC_RNA_ANALYZER as SPATIAL_RNA_ANALYZER(
        aggregate_barcodes = _BASIC_SPATIAL_RNA_COUNTER.aggregate_barcodes,
        analyzer_inputs    = {
            aggr_library_info:          null,
            cbc_alpha:                  null,
            cbc_knn:                    null,
            cbc_realign_panorama:       null,
            cbc_sigma:                  null,
            chemistry_batch_correction: false,
            exclude_genes:              null,
            filtered_matrices_h5:       _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
            # NOTE: this is null because the cells are already forced in FILTER_BARCODES
            force_cells:                null,
            graphclust_neighbors:       null,
            graphclust_resolution:      null,
            is_pd:                      self.is_pd,
            is_spatial:                 true,
            is_visium_hd:               false,
            max_clusters:               null,
            molecule_info:              _BASIC_SPATIAL_RNA_COUNTER.molecule_info,
            neighbor_a:                 null,
            neighbor_b:                 null,
            no_secondary_analysis:      DISABLE_SECONDARY_ANALYSIS.no_secondary_analysis,
            num_analysis_bcs:           null,
            num_pca_bcs:                null,
            num_pca_genes:              null,
            num_principal_comps:        null,
            random_seed:                null,
            skip_multigenome_analysis:  true,
            tsne_input_pcs:             null,
            tsne_max_dims:              null,
            tsne_max_iter:              null,
            tsne_mom_switch_iter:       null,
            tsne_perplexity:            null,
            tsne_stop_lying_iter:       null,
            tsne_theta:                 null,
            umap_implementation:        "original",
            umap_input_pcs:             null,
            umap_max_dims:              null,
            umap_metric:                null,
            umap_min_dist:              null,
            umap_n_neighbors:           null,
            use_bcs:                    null,
            use_genes:                  null,
        },
    )

    call DECONVOLVE_SPOTS(
        filtered_matrix = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        analysis        = SPATIAL_RNA_ANALYZER.common_analyzer.analysis,
    ) using (
        disabled = DISABLE_DECONVOLUTION.disable_deconvolution,
    )

    call _TARGETED_ANALYZER(
        molecule_info             = _BASIC_SPATIAL_RNA_COUNTER.molecule_info,
        filtered_gene_bc_matrices = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        filtered_barcodes         = _BASIC_SPATIAL_RNA_COUNTER.filtered_barcodes,
        basic_counter_summary     = _BASIC_SPATIAL_RNA_COUNTER.summary,
        reference_path            = self.reference_path,
        probe_set                 = PARSE_TARGET_FEATURES.probe_set,
        target_panel_summary      = PARSE_TARGET_FEATURES.target_panel_summary,
        is_spatial                = true,
        is_visium_hd              = self.is_visium_hd,
    ) using (
        disabled = PARSE_TARGET_FEATURES.disable_targeted,
    )

    call ANTIBODY_QC_PLOTS(
        filtered_matrix = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        raw_matrix      = _BASIC_SPATIAL_RNA_COUNTER.raw_gene_bc_matrices_h5,
    ) using (
        disabled = DISABLE_FEATURE_STAGES.disable_antibody,
    )

    call SPATIAL_FOLDER_COLLECTOR(
        aligned_fiducials     = self.aligned_fiducials,
        detected_tissue_image = self.detected_tissue_img,
        scalefactors          = self.image_scale_factors,
        tissue_transform_json = self.tissue_transform_json,
        tissue_hires_image    = self.tissue_hires_img,
        tissue_lowres_image   = self.tissue_lowres_img,
        cytassist_image       = self.cytassist_image,
        qc_resampled_cyta_img = self.qc_resampled_cyta_img,
        qc_regist_target_img  = self.qc_regist_target_img,
        aligned_tissue_image  = self.aligned_tissue_img,
        tissue_positions      = self.tissue_positions,
        spatial_enrichment    = RUN_SPATIAL_ENRICHMENT.spatial_enrichment_csv,
        barcode_fluorescence_intensity = self.barcode_fluorescence_intensity,
        is_visium_hd          = self.is_visium_hd,
    )

    # For HD slides, bin the data at different scales and perform
    # secondary analysis at each of the bin levels
    call BIN_HD_DATA(
        spatial                      = SPATIAL_FOLDER_COLLECTOR.spatial,
        filtered_matrix_h5           = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        raw_matrix_h5                = _BASIC_SPATIAL_RNA_COUNTER.raw_gene_bc_matrices_h5,
        counts_bc_order              = _BASIC_SPATIAL_RNA_COUNTER.counts_bc_order,
        slfe_feature_reference       = _BASIC_SPATIAL_RNA_COUNTER.slfe_feature_reference,
        barcode_summary_h5           = _BASIC_SPATIAL_RNA_COUNTER.barcode_summary,
        molecule_info                = _BASIC_SPATIAL_RNA_COUNTER.molecule_info,
        metrics_json                 = _BASIC_SPATIAL_RNA_COUNTER.summary,
        raw_probe_bc_matrix_base_bin = _BASIC_SPATIAL_RNA_COUNTER.raw_probe_bc_matrix,
        barcode_index                = _BASIC_SPATIAL_RNA_COUNTER.barcode_index,
        *                            = self,
    )

    call WEBSUMMARY_ALERTS(
        loupe_alignment_file  = self.loupe_alignment_file,
        cytassist_image_paths = self.cytassist_image_paths,
        is_visium_hd          = self.is_visium_hd,
    )

    call SPATIAL_REPORTER(
        summaries                   = [
            _BASIC_SPATIAL_RNA_COUNTER.summary,
            SPATIAL_RNA_ANALYZER.common_analyzer.summary,
            self.alignment_metrics,
            self.tissue_registration_metrics,
            _TARGETED_ANALYZER.targeted_analysis_metrics,
            RUN_SPATIAL_ENRICHMENT.spatial_enrichment_json,
            self.fraction_bc_outside_image,
            BIN_HD_DATA.summary,
        ],
        sample_id                   = self.sample_id,
        slide_serial_info           = self.slide_serial_capture_area,
        sample_desc                 = self.sample_desc,
        chemistry_defs              = self.chemistry_defs,
        reference_path              = self.reference_path,
        barcode_summary_h5          = _BASIC_SPATIAL_RNA_COUNTER.barcode_summary,
        filtered_barcodes           = _BASIC_SPATIAL_RNA_COUNTER.filtered_barcodes,
        fraction_under_tissue       = self.fraction_under_tissue,
        feature_reference           = self.feature_reference,
        aligned_fiducials           = self.aligned_fiducials,
        matrix                      = _BASIC_SPATIAL_RNA_COUNTER.raw_gene_bc_matrices_h5,
        analysis                    = SPATIAL_RNA_ANALYZER.common_analyzer.analysis,
        gem_groups                  = _BASIC_SPATIAL_RNA_COUNTER.gem_groups,
        target_set_name             = PARSE_TARGET_FEATURES.target_set_name,
        targeting_method            = PARSE_TARGET_FEATURES.targeting_method,
        target_panel_summary        = PARSE_TARGET_FEATURES.target_panel_summary,
        antibody_histograms         = SPATIAL_RNA_ANALYZER.antibody_analyzer.antibody_histograms_json,
        antibody_treemap            = SPATIAL_RNA_ANALYZER.antibody_analyzer.antibody_treemap_json,
        raw_normalized_heatmap      = ANTIBODY_QC_PLOTS.raw_normalized_heatmap,
        isotype_scatter             = ANTIBODY_QC_PLOTS.isotype_scatter,
        gex_fbc_correlation_heatmap = ANTIBODY_QC_PLOTS.gex_fbc_correlation_heatmap,
        ab_qc_summary               = ANTIBODY_QC_PLOTS.ab_qc_summary,
        per_feature_metrics_csv     = _TARGETED_ANALYZER.per_feature_metrics_csv,
        reorientation_mode          = self.reorientation_mode,
        filter_probes               = self.filter_probes,
        include_introns             = self.include_introns,
        aligner                     = self.aligner,
        loupe_alignment_file        = self.loupe_alignment_file,
        scalefactors                = self.image_scale_factors,
        tissue_positions            = self.tissue_positions,
        tissue_image_paths          = self.tissue_image_paths,
        tissue_hires_image          = self.tissue_hires_img,
        tissue_lowres_image         = self.tissue_lowres_img,
        cytassist_image             = self.cytassist_image,
        detected_tissue_image       = self.detected_tissue_img,
        qc_resampled_cyta_img       = self.qc_resampled_cyta_img,
        qc_regist_target_img        = self.qc_regist_target_img,
        cytassist_image_paths       = self.cytassist_image_paths,
        v1_filtered_fbm             = self.v1_filtered_fbm,
        hd_layout_data_json         = self.hd_layout_data_json,
        override_id                 = self.override_id,
        slide_id_mismatch           = WEBSUMMARY_ALERTS.slide_id_mismatch,
        is_visium_hd                = self.is_visium_hd,
    )

    call HD_WEBSUMMARY_BUILDER(
        sd_web_summary_json = SPATIAL_REPORTER.web_summary_json,
        bin_level_metrics   = BIN_HD_DATA.bin_level_metrics,
        hd_feature_slice    = BIN_HD_DATA.hd_feature_slice_h5,
        scalefactors        = self.scalefactors,
        dark_images         = self.dark_images,
        tissue_hires_image  = SPATIAL_FOLDER_COLLECTOR.spatial.tissue_hires_image,
        analysis_h5         = BIN_HD_DATA.binned_outputs.analysis,
        saturation_plots    = BIN_HD_DATA.binned_outputs.saturation_plots,
    ) using (
        disabled = BIN_HD_DATA.disable_binning,
    )

    return (
        gene_index                    = WRITE_GENE_INDEX.gene_index,
        bam_header                    = _BASIC_SPATIAL_RNA_COUNTER.bam_header,
        possorted_genome_bam          = _BASIC_SPATIAL_RNA_COUNTER.possorted_genome_bam,
        possorted_genome_bai_index    = _BASIC_SPATIAL_RNA_COUNTER.possorted_genome_bai_index,
        possorted_genome_csi_index    = _BASIC_SPATIAL_RNA_COUNTER.possorted_genome_csi_index,
        web_summary                   = SPATIAL_REPORTER.web_summary,
        web_summary_json              = SPATIAL_REPORTER.web_summary_json,
        spatial                       = SPATIAL_FOLDER_COLLECTOR.spatial,
        metrics_summary_json          = SPATIAL_REPORTER.metrics_summary_json,
        metrics_summary_csv           = SPATIAL_REPORTER.metrics_summary_csv,
        feature_reference             = SPATIAL_REPORTER.feature_reference,
        barcode_summary               = _BASIC_SPATIAL_RNA_COUNTER.barcode_summary,
        molecule_info                 = _BASIC_SPATIAL_RNA_COUNTER.molecule_info,
        raw_gene_bc_matrices_h5       = _BASIC_SPATIAL_RNA_COUNTER.raw_gene_bc_matrices_h5,
        raw_gene_bc_matrices_mex      = _BASIC_SPATIAL_RNA_COUNTER.raw_gene_bc_matrices_mex,
        filtered_gene_bc_matrices_h5  = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        filtered_gene_bc_matrices_mex = _BASIC_SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_mex,
        analysis                      = SPATIAL_RNA_ANALYZER.common_analyzer.analysis,
        analysis_csv                  = SPATIAL_RNA_ANALYZER.common_analyzer.analysis_csv,
        read_shards                   = _BASIC_SPATIAL_RNA_COUNTER.read_shards,
        gem_groups                    = _BASIC_SPATIAL_RNA_COUNTER.gem_groups,
        filtered_barcodes             = _BASIC_SPATIAL_RNA_COUNTER.filtered_barcodes,
        barcode_correction_csv        = _BASIC_SPATIAL_RNA_COUNTER.barcode_correction_csv,
        annotation_files              = _BASIC_SPATIAL_RNA_COUNTER.annotation_files,
        barcode_counts                = _BASIC_SPATIAL_RNA_COUNTER.barcode_counts,
        alignments                    = _BASIC_SPATIAL_RNA_COUNTER.alignments,
        read_chunks                   = _BASIC_SPATIAL_RNA_COUNTER.read_chunks,
        per_barcode_metrics           = _BASIC_SPATIAL_RNA_COUNTER.per_barcode_metrics,
        disable_targeted              = PARSE_TARGET_FEATURES.disable_targeted,
        target_panel                  = PARSE_TARGET_FEATURES.target_panel,
        probe_set                     = PARSE_TARGET_FEATURES.probe_set,
        target_panel_or_probe_set     = PARSE_TARGET_FEATURES.target_panel_or_probe_set,
        target_set_name               = PARSE_TARGET_FEATURES.target_set_name,
        targeting_method              = PARSE_TARGET_FEATURES.targeting_method,
        per_feature_metrics_csv       = _TARGETED_ANALYZER.per_feature_metrics_csv,
        bait_fasta                    = PARSE_TARGET_FEATURES.bait_fasta,
        spatial_enrichment            = RUN_SPATIAL_ENRICHMENT.spatial_enrichment_csv,
        clustering_h5                 = SPATIAL_RNA_ANALYZER.clustering_h5,
        per_probe_metrics             = _BASIC_SPATIAL_RNA_COUNTER.per_probe_metrics,
        isotype_normalization_factors = _BASIC_SPATIAL_RNA_COUNTER.isotype_normalization_factors,
        raw_probe_bc_matrix           = _BASIC_SPATIAL_RNA_COUNTER.raw_probe_bc_matrix,
        deconvolution                 = DECONVOLVE_SPOTS.deconvolution,
        counts_bc_order               = _BASIC_SPATIAL_RNA_COUNTER.counts_bc_order,
        slfe_feature_reference        = _BASIC_SPATIAL_RNA_COUNTER.slfe_feature_reference,
        raw_normalized_heatmap        = ANTIBODY_QC_PLOTS.raw_normalized_heatmap,
        isotype_scatter               = ANTIBODY_QC_PLOTS.isotype_scatter,
        gex_fbc_correlation_heatmap   = ANTIBODY_QC_PLOTS.gex_fbc_correlation_heatmap,
        no_star_alignments            = _BASIC_SPATIAL_RNA_COUNTER.no_star_alignments,
        barcode_index                 = _BASIC_SPATIAL_RNA_COUNTER.barcode_index,
        binned_outputs                = BIN_HD_DATA.binned_outputs,
        base_binned_outputs           = BIN_HD_DATA.binned_outputs,
        hd_web_summary                = HD_WEBSUMMARY_BUILDER.web_summary,
        hd_feature_slice              = BIN_HD_DATA.hd_feature_slice_h5,
        disable_binning               = BIN_HD_DATA.disable_binning,
        bin_infos                     = BIN_HD_DATA.bin_infos,
        alignment_qc_outs             = BIN_HD_DATA.alignment_qc_outs,
        summary                       = BIN_HD_DATA.summary,
    )
}

#
# @include "spatial_rna_counter_prep.mro"
#

pipeline SPATIAL_RNA_COUNTER_PREP(
    in  string            sample_id,
    in  map[]             sample_def,
    in  string            chemistry,
    in  ChemistryDef      custom_chemistry_def,
    in  path              reference_path,
    in  int               r1_length             "Trim input R1 to this length (optional)",
    in  int               r2_length             "Trim input R2 to this length (optional)",
    in  bool              is_pd,
    in  string[]          allowed_chems,
    out map[]             chunks,
    out map<ChemistryDef> chemistry_defs,
    out string            barcode_whitelist,
    out string            visium_hd_slide_name,
    out bool              is_antibody_only,
)
{
    call COPY_CHEMISTRY_SPEC(
        sample_defs    = self.sample_def,
        chemistry_spec = self.chemistry,
    )

    call DETECT_CHEMISTRY(
        sample_def           = self.sample_def,
        reference_path       = self.reference_path,
        chemistry_specs      = COPY_CHEMISTRY_SPEC.chemistry_specs,
        custom_chemistry_def = self.custom_chemistry_def,
        allowed_chems        = self.allowed_chems,
        r1_length            = self.r1_length,
        r2_length            = self.r2_length,
        is_pd                = self.is_pd,
        feature_reference    = null,
        multi_config         = null,
        feature_config       = null,
    )

    call MULTI_SETUP_CHUNKS(
        sample_id            = self.sample_id,
        sample_def           = self.sample_def,
        chemistry_defs       = DETECT_CHEMISTRY.chemistry_defs,
        default_library_type = null,
    ) using (
        local    = true,
        volatile = true,
    )

    return (
        chunks               = MULTI_SETUP_CHUNKS.chunks,
        chemistry_defs       = DETECT_CHEMISTRY.chemistry_defs,
        barcode_whitelist    = MULTI_SETUP_CHUNKS.barcode_whitelist,
        visium_hd_slide_name = MULTI_SETUP_CHUNKS.visium_hd_slide_name,
        is_antibody_only     = DETECT_CHEMISTRY.is_antibody_only,
    )
}

#
# @include "_spatial_cloupe_stages.mro"
#

stage CLOUPE_TILE_IMAGES(
    in  file[] tissue_image_paths,
    in  int    tile_size,
    in  bool   skip_stage,
    in  bool   no_secondary_analysis,
    in  path   loupe_alignment_file,
    out json   dzi_info,
    out path[] dzi_tiles_paths,
    src py     "stages/cloupe/cloupe_tile_images",
) split (
) using (
    mem_gb  = 3,
    vmem_gb = 12,
)

stage MERGE_TISSUE_FILES(
    in  map[] sample_defs,
    out csv   aggr_tissue_positions,
    out path  spatial,
    out json  loupe_map,
    src py    "stages/spatial/merge_tissue_files",
)

stage VERIFY_SPATIAL_CLOUPES(
    in  map[] sample_defs,
    src py    "stages/cloupe/verify_spatial_cloupes",
) using (
    volatile = strict,
)

#
# @include "_spatial_imaging_stages.mro"
#

stage DETERMINE_PIPELINE_MODE(
    in  file[]       tissue_image_paths,
    in  file[]       cytassist_image_paths,
    in  string       visium_hd_slide_name,
    in  string       barcode_whitelist,
    out PipelineMode pipeline_mode,
    out bool         is_visium_hd,
    out bool         is_visium_sd,
    src py           "stages/spatial/determine_pipeline_mode",
) using (
    volatile = strict,
)

stage STANDARDIZE_IMAGES(
    in  PipelineMode pipeline_mode,
    in  file[]       tissue_image_paths,
    in  file[]       cytassist_image_paths,
    in  int          dark_images,
    in  int          dapi_channel_index,
    in  path         loupe_alignment_file,
    in  bool         read_metadata_from_tissue_image,
    in  float        tissue_image_pixel_size_in,
    out json         scalefactors_json,
    out json         crop_info_json,
    out png          fiducials_detection_image,
    out png          tissue_detection_grayscale_image,
    out png          tissue_detection_saturation_image,
    out png          qc_cytassist_crop_image,
    out tiff         registration_target_image,
    out tiff         cytassist_image,
    out bool         skip_tissue_registration,
    out float        tissue_image_pixel_size,
    out png          tissue_hires_image,
    out png          tissue_lowres_image,
    out file[]       cloupe_display_image_paths,
    src py           "stages/spatial/standardize_images",
) split (
) using (
    mem_gb   = 3,
    vmem_gb  = 25,
    volatile = strict,
)

stage LOUPE_ALIGNMENT_READER(
    in  path         loupe_alignment_file,
    in  PipelineMode pipeline_mode,
    in  json         scalefactors_json,
    out json         loupe_spots_data_json,
    out json         loupe_cyta_data_json,
    out json         hd_slide_layout_json,
    out string[]     image_page_names,
    src py           "stages/spatial/loupe_alignment_reader",
) split (
) using (
    volatile = strict,
)

stage GPR_READER(
    in  string slide_serial_capture_area,
    in  gpr    gpr_file,
    in  string barcode_whitelist,
    in  json   loupe_spots_data_json,
    out json   gpr_spots_data_json,
    src py     "stages/spatial/gpr_reader",
) using (
    volatile = strict,
)

stage HD_LAYOUT_READER(
    in  string slide_serial_capture_area,
    in  vlf    hd_layout_file,
    in  string visium_hd_slide_name,
    in  json   loupe_hd_slide_layout_json,
    out json   hd_layout_data_json,
    src py     "stages/spatial/hd_layout_reader",
) using (
    volatile = strict,
)

stage ALIGN_FIDUCIALS(
    in  PipelineMode pipeline_mode,
    in  png          fiducials_detection_image,
    in  json         gpr_spots_data_json,
    in  json         hd_layout_data_json,
    in  json         loupe_spots_data_json,
    in  string       visium_hd_slide_name,
    in  string       reorientation_mode,
    in  json         crop_info_json,
    in  bool         is_visium_hd,
    out json         registered_spots_data_json,
    out json         fiducial_alignment_metrics,
    out json         transform_matrix,
    out map<file>    qc_detected_fiducials_images,
    out jpg          qc_aligned_fiducials_image,
    out jpg          qc_fiducial_error_image,
    out float[][]    fid_perp_tmat,
    src py           "stages/spatial/align_fiducials",
) split (
) using (
    volatile = strict,
) retain (
    qc_detected_fiducials_images,
)

stage DETECT_TISSUE(
    in  PipelineMode pipeline_mode,
    in  png          tissue_detection_grayscale_image,
    in  png          tissue_detection_saturation_image,
    in  bool         skip_tissue_detection,
    in  bool         ignore_loupe_tissue_detection,
    in  json         registered_spots_data_json,
    in  bool         use_experimental_image_processing,
    out json         registered_selected_spots_json,
    out json         tissue_mask_metrics,
    out jpg          qc_detected_tissue_image,
    out jpg          detected_tissue_mask,
    out jpg          initialisation_debug,
    out png          grabcut_markers,
    src py           "stages/spatial/detect_tissue",
) split (
) using (
    volatile = strict,
)

stage OUTPUT_SPOTS_BARCODES(
    in  json   registered_selected_spots_json,
    in  json   tissue_transform_json,
    in  json   scalefactors,
    in  string barcode_whitelist,
    in  string visium_hd_slide_name,
    in  png    tissue_lowres_image,
    out txt    final_spot_position_list,
    out txt    final_fiducial_position_list,
    out csv    tissue_positions,
    out json   barcodes_under_tissue,
    out float  fraction_under_tissue,
    out json   tissue_final_transform_json,
    out json   scalefactors,
    out json   fraction_bc_outside_image,
    src py     "stages/spatial/output_spots_barcodes",
) split (
) using (
    volatile = strict,
)

stage CALCULATE_FLUORESCENCE_INTENSITY(
    in  file[]       tissue_image_paths,
    in  int          dark_images,
    in  json         scalefactors_json,
    in  csv          tissue_positions,
    in  string       barcode_whitelist,
    in  string[]     image_page_names,
    in  path         loupe_alignment_file,
    in  PipelineMode pipeline_mode,
    out csv          barcode_fluorescence_intensity,
    src py           "stages/spatial/calculate_fluorescence_intensity",
) split (
) using (
    mem_gb   = 1,
    threads  = 1,
    volatile = strict,
)

stage REGISTER_TISSUE(
    in  png       tissue_detection_image,
    in  tiff      registration_target_image,
    in  json      loupe_tissue_registration_json,
    in  json      crop_info_json,
    in  float[][] fid_perp_tmat,
    in  bool      is_visium_hd,
    in  float     tissue_image_pixel_size,
    in  bool      is_pd,
    out json      tissue_transform_json,
    out json      tissue_registration_metrics,
    out tiff      resampled_cyta_img,
    out jpg       qc_registered_tissue_image,
    out jpg       qc_resampled_cyta_img,
    out jpg       qc_regist_target_img,
    out jpg       cytassist_tissue_detection_debug,
    out jpg       target_tissue_detection_debug,
    out jpg       max_mutual_info_init_debug,
    src py        "stages/spatial/register_tissue",
) split (
    in  bool      flip,
    in  float[]   rot_angle_list,
    in  float     scale_for_registration,
    out float     metric,
    out string    stop_description,
    out float[]   transform_mat,
    out jpg       chunk_cytassist_tissue_detection_debug,
    out jpg       chunk_target_tissue_detection_debug,
    out jpg       chunk_max_mutual_info_init_debug,
) using (
    mem_gb   = 8,
    volatile = strict,
)

#
# @include "_spatial_imaging_cs.mro"
#

pipeline _SPATIAL_IMAGING_CS(
    in  string   slide_serial_capture_area       "Slide serial number and area id",
    in  path     loupe_alignment_file            "Path to Loupe-generated manual alignment file",
    in  gpr      gpr_file                        "Slide GPR file",
    in  vlf      hd_layout_file                  "Visium HD slide layout file",
    in  string   reorientation_mode              "rotate ('rotation') or rotate+mirror ('rotation+mirror') fiducial template to find best alignment",
    in  file[]   tissue_image_paths              "Path(s) to slide image(s)",
    in  file[]   cytassist_image_paths           "Path(s) to CytAssist image(s)",
    in  int      dark_images                     "Path(s) to dark background images",
    in  int      dapi_channel_index              "Index of the DAPI channel if the tissue image is dark image",
    in  string   barcode_whitelist               "Whitelisted barcodes CSV",
    in  string   visium_hd_slide_name            "Name of slide if Visium HD",
    in  string[] image_page_names                "Name(s) of each page of the dark image",
    in  bool     skip_tissue_detection           "Skip the tissue detection step and select all spots",
    in  float    tissue_image_pixel_size         "Pixel size in microns per pixel of tissue image",
    out jpg      aligned_fiducials               "Slide image annotated with fiducial alignment",
    out jpg      detected_tissue_image           "Slide image annotated with detected tissue",
    out jpg      qc_resampled_cyta_img           "Transformed CytAssist image to the tissue hi-res image space",
    out jpg      qc_regist_target_img            "The high resolution image to which the CytAssist image is transformed",
    out jpg      aligned_tissue_image            "Registration image between CytAssist image and microscope image",
    out csv      tissue_positions                "Slide position and tissue status of barcodes CSV",
    out txt      fiducial_positions_list         "Slide position of fiducial spots CSV",
    out json     barcodes_under_tissue           "Slide position and tissue status of barcodes JSON",
    out float    fraction_under_tissue           "Fraction of barcodes under tissue",
    out json     image_scalefactors              "Scale factors for hires and lowres images and fiducial and spot diameters",
    out json     alignment_metrics               "Metrics from fiducial alignment procedure",
    out png      tissue_hires_image              "Slide image scaled to 2000px in the largest dimension",
    out png      tissue_lowres_image             "Slide image scaled to 600px in the largest dimension",
    out tiff     cytassist_image                 "RGB brightfield image generated by CytAssist instrument",
    out csv      barcode_fluorescence_intensity  "Fluorescence intensity at spot",
    out string[] cloupe_image_page_names         "Name(s) of each page of the dark image specified in the loupe alignment file",
    out file[]   cloupe_display_image_paths      "Images used in cloupe file",
    out json     fraction_bc_outside_image       "Fraction of barcodes outside of the original resolution image boundries",
    out json     hd_layout_data_json,
    out json     tissue_transform_json,
    out json     tissue_registration_metrics,
    out json     fiducial_transform,
    out tiff     registration_target_image,
    out bool     is_visium_hd,
)
{
    call DETERMINE_PIPELINE_MODE(
        tissue_image_paths    = self.tissue_image_paths,
        cytassist_image_paths = self.cytassist_image_paths,
        visium_hd_slide_name  = self.visium_hd_slide_name,
        barcode_whitelist     = self.barcode_whitelist,
    )

    call STANDARDIZE_IMAGES(
        pipeline_mode              = DETERMINE_PIPELINE_MODE.pipeline_mode,
        tissue_image_paths         = self.tissue_image_paths,
        cytassist_image_paths      = self.cytassist_image_paths,
        tissue_image_pixel_size_in = self.tissue_image_pixel_size,
        read_metadata_from_tissue_image = false,
        dark_images                = self.dark_images,
        dapi_channel_index         = self.dapi_channel_index,
        loupe_alignment_file       = self.loupe_alignment_file,
    )

    call LOUPE_ALIGNMENT_READER(
        loupe_alignment_file = self.loupe_alignment_file,
        pipeline_mode        = DETERMINE_PIPELINE_MODE.pipeline_mode,
        scalefactors_json    = STANDARDIZE_IMAGES.scalefactors_json,
    )

    call GPR_READER(
        slide_serial_capture_area = self.slide_serial_capture_area,
        gpr_file                  = self.gpr_file,
        barcode_whitelist         = self.barcode_whitelist,
        loupe_spots_data_json     = LOUPE_ALIGNMENT_READER.loupe_spots_data_json,
    ) using (
        disabled = DETERMINE_PIPELINE_MODE.is_visium_hd,
    )

    call HD_LAYOUT_READER(
        slide_serial_capture_area  = self.slide_serial_capture_area,
        hd_layout_file             = self.hd_layout_file,
        visium_hd_slide_name       = self.visium_hd_slide_name,
        loupe_hd_slide_layout_json = LOUPE_ALIGNMENT_READER.hd_slide_layout_json,
    ) using (
        disabled = DETERMINE_PIPELINE_MODE.is_visium_sd,
    )

    call ALIGN_FIDUCIALS(
        pipeline_mode             = DETERMINE_PIPELINE_MODE.pipeline_mode,
        fiducials_detection_image = STANDARDIZE_IMAGES.fiducials_detection_image,
        gpr_spots_data_json       = GPR_READER.gpr_spots_data_json,
        hd_layout_data_json       = HD_LAYOUT_READER.hd_layout_data_json,
        loupe_spots_data_json     = LOUPE_ALIGNMENT_READER.loupe_spots_data_json,
        reorientation_mode        = self.reorientation_mode,
        crop_info_json            = STANDARDIZE_IMAGES.crop_info_json,
        visium_hd_slide_name      = self.visium_hd_slide_name,
        is_visium_hd              = DETERMINE_PIPELINE_MODE.is_visium_hd,
    )

    call DETECT_TISSUE(
        pipeline_mode                 = DETERMINE_PIPELINE_MODE.pipeline_mode,
        tissue_detection_grayscale_image = STANDARDIZE_IMAGES.tissue_detection_grayscale_image,
        tissue_detection_saturation_image = STANDARDIZE_IMAGES.tissue_detection_saturation_image,
        skip_tissue_detection         = self.skip_tissue_detection,
        registered_spots_data_json    = ALIGN_FIDUCIALS.registered_spots_data_json,
        use_experimental_image_processing = false,
        ignore_loupe_tissue_detection = false,
    )

    call REGISTER_TISSUE(
        tissue_detection_image    = STANDARDIZE_IMAGES.tissue_detection_grayscale_image,
        registration_target_image = STANDARDIZE_IMAGES.registration_target_image,
        crop_info_json            = STANDARDIZE_IMAGES.crop_info_json,
        tissue_image_pixel_size   = STANDARDIZE_IMAGES.tissue_image_pixel_size,
        loupe_tissue_registration_json = LOUPE_ALIGNMENT_READER.loupe_cyta_data_json,
        fid_perp_tmat             = ALIGN_FIDUCIALS.fid_perp_tmat,
        is_visium_hd              = DETERMINE_PIPELINE_MODE.is_visium_hd,
        is_pd                     = false,
    ) using (
        disabled = STANDARDIZE_IMAGES.skip_tissue_registration,
    )

    call OUTPUT_SPOTS_BARCODES(
        registered_selected_spots_json = DETECT_TISSUE.registered_selected_spots_json,
        tissue_transform_json = REGISTER_TISSUE.tissue_transform_json,
        scalefactors          = STANDARDIZE_IMAGES.scalefactors_json,
        barcode_whitelist     = self.barcode_whitelist,
        tissue_lowres_image   = STANDARDIZE_IMAGES.tissue_lowres_image,
        visium_hd_slide_name  = self.visium_hd_slide_name,
    )

    call CALCULATE_FLUORESCENCE_INTENSITY(
        tissue_image_paths   = self.tissue_image_paths,
        dark_images          = self.dark_images,
        scalefactors_json    = OUTPUT_SPOTS_BARCODES.scalefactors,
        tissue_positions     = OUTPUT_SPOTS_BARCODES.tissue_positions,
        barcode_whitelist    = self.barcode_whitelist,
        image_page_names     = self.image_page_names,
        loupe_alignment_file = self.loupe_alignment_file,
        pipeline_mode        = DETERMINE_PIPELINE_MODE.pipeline_mode,
    )

    return (
        fiducial_positions_list     = OUTPUT_SPOTS_BARCODES.final_fiducial_position_list,
        tissue_positions            = OUTPUT_SPOTS_BARCODES.tissue_positions,
        barcodes_under_tissue       = OUTPUT_SPOTS_BARCODES.barcodes_under_tissue,
        fraction_under_tissue       = OUTPUT_SPOTS_BARCODES.fraction_under_tissue,
        image_scalefactors          = OUTPUT_SPOTS_BARCODES.scalefactors,
        tissue_hires_image          = STANDARDIZE_IMAGES.tissue_hires_image,
        tissue_lowres_image         = STANDARDIZE_IMAGES.tissue_lowres_image,
        cytassist_image             = STANDARDIZE_IMAGES.cytassist_image,
        aligned_fiducials           = ALIGN_FIDUCIALS.qc_aligned_fiducials_image,
        detected_tissue_image       = DETECT_TISSUE.qc_detected_tissue_image,
        qc_resampled_cyta_img       = REGISTER_TISSUE.qc_resampled_cyta_img,
        qc_regist_target_img        = REGISTER_TISSUE.qc_regist_target_img,
        aligned_tissue_image        = REGISTER_TISSUE.qc_registered_tissue_image,
        alignment_metrics           = ALIGN_FIDUCIALS.fiducial_alignment_metrics,
        cloupe_display_image_paths  = STANDARDIZE_IMAGES.cloupe_display_image_paths,
        barcode_fluorescence_intensity = CALCULATE_FLUORESCENCE_INTENSITY.barcode_fluorescence_intensity,
        cloupe_image_page_names     = LOUPE_ALIGNMENT_READER.image_page_names,
        fraction_bc_outside_image   = OUTPUT_SPOTS_BARCODES.fraction_bc_outside_image,
        hd_layout_data_json         = HD_LAYOUT_READER.hd_layout_data_json,
        tissue_transform_json       = OUTPUT_SPOTS_BARCODES.tissue_final_transform_json,
        tissue_registration_metrics = REGISTER_TISSUE.tissue_registration_metrics,
        fiducial_transform          = ALIGN_FIDUCIALS.transform_matrix,
        registration_target_image   = STANDARDIZE_IMAGES.registration_target_image,
        is_visium_hd                = DETERMINE_PIPELINE_MODE.is_visium_hd,
    )
}

#
# @include "_spatial_preflights.mro"
#

stage SPACERANGER_PREFLIGHT(
    in  map[]        sample_def,
    in  path         reference_path,
    in  csv          feature_reference,
    in  int          recovered_cells,
    in  int          force_cells,
    in  int          r1_length,
    in  int          r2_length,
    in  file[]       tissue_image_paths,
    in  int          dark_images,
    in  int          dapi_channel_index,
    in  path         loupe_alignment_file,
    in  bool         override_id,
    in  gpr          gpr_file,
    in  vlf          hd_layout_file,
    in  file[]       cytassist_image_paths,
    in  tgz          cytassist_tgz_path,
    in  bool         check_cytassist_sizes,
    in  string       slide_serial_capture_area,
    in  string       targeting_method,
    in  string       chemistry,
    in  ChemistryDef custom_chemistry_def,
    in  h5           v1_filtered_fbm,
    in  path         hd_log_umi_image,
    in  bool         is_pd,
    src py           "stages/common/spaceranger_preflight",
) split (
) using (
    mem_gb  = 3,
    vmem_gb = 16,
)

stage SPACERANGER_PREFLIGHT_LOCAL(
    in  map[]        sample_def,
    in  path         reference_path,
    in  csv          feature_reference,
    in  int          recovered_cells,
    in  int          force_cells,
    in  int          r1_length,
    in  int          r2_length,
    in  file[]       tissue_image_paths,
    in  int          dark_images,
    in  path         loupe_alignment_file,
    in  gpr          gpr_file,
    in  vlf          hd_layout_file,
    in  file[]       cytassist_image_paths,
    in  string       slide_serial_capture_area,
    in  string       targeting_method,
    in  string       chemistry,
    in  ChemistryDef custom_chemistry_def,
    in  h5           v1_filtered_fbm,
    in  bool         is_pd,
    src py           "stages/common/spaceranger_preflight_local",
)

#
# @include "rna/spatial_rna_counter_cs.mro"
#

pipeline SPATIAL_RNA_COUNTER_CS(
    in  string               sample_id                      "A unique run id",
    in  map[]                sample_def                     "Sample definition",
    in  string               sample_desc                    "Sample description to embed in output files",
    in  string               slide_serial_capture_area      "Slide serial number and area id",
    in  path                 loupe_alignment_file           "Path to Loupe-generated manual alignment file",
    in  gpr                  gpr_file                       "Slide GPR file",
    in  vlf                  hd_layout_file                 "Layout file for Visium HD",
    in  path                 reference_path                 "Path to reference",
    in  bool                 no_bam                         "Skip generating BAM file outputs",
    in  bool                 no_secondary_analysis          "Flag to disable clustering and dimensionality reduction",
    in  bool                 filter_probes                  "Filter the probe set",
    in  int                  r1_length                      "Trim input R1 to this length (optional)",
    in  int                  r2_length                      "Trim input R2 to this length (optional)",
    in  string               targeting_method               "Either 'templated_ligation' or 'hybrid_capture'",
    in  string               aligner                        "Either 'star' or 'hurtle'",
    in  string               chemistry                      "Identifies the whitelist and slide revision",
    in  int                  trim_polya_min_score,
    in  int                  trim_tso_min_score,
    in  csv                  feature_reference,
    in  file[]               tissue_image_paths             "Path to brightfield slide image or fluorescence (dark) images",
    in  int                  dark_images                    "null or 0 for brightfield, 1 for fluoro channels, 2 for single pre-colorized image",
    in  string[]             image_page_names               "Name(s) of each page of the dark image",
    in  string               reorientation_mode             "Set rotation or rotation+mirror to reorient input images",
    in  file[]               cytassist_image_paths          "Image generated by CytAssist instrument",
    in  int                  dapi_channel_index             "Index of the DAPI channel if the tissue image is dark image",
    in  bool                 skip_tissue_detection          "Skip tissue segmentation and analyze all spots",
    in  bool                 include_introns                "Include introns during UMI counting",
    in  int                  custom_bin_size                "Bin HD data at the supplied bin level in addition to the standard binning levels",
    in  float                image_scale                    "Pixel size in microns per pixel of tissue image",
    in  bool                 override_id                    "True if the slide-ID provided in the Cytassist Image Metadata should be overridden",
    in  h5                   v1_filtered_fbm                "Previous filtered_feature_bc_matrix for chevron fix",
    out html                 web_summary                    "Run summary HTML",
    out SpatialFolder        spatial                        "Outputs of spatial pipeline",
    out csv                  metrics_summary                "Run summary CSV",
    out bam                  possorted_genome_bam           "BAM"                       "possorted_genome_bam.bam",
    out bam.bai              possorted_genome_bai_index     "BAM BAI index"             "possorted_genome_bam.bam.bai",
    out bam.csi              possorted_genome_csi_index     "BAM CSI index"             "possorted_genome_bam.bam.csi",
    out path                 filtered_feature_bc_matrix     "Filtered feature-barcode matrices MEX",
    out h5                   filtered_feature_bc_matrix_h5  "Filtered feature-barcode matrices HDF5"  "filtered_feature_bc_matrix.h5",
    out path                 raw_feature_bc_matrix          "Unfiltered feature-barcode matrices MEX",
    out h5                   raw_feature_bc_matrix_h5       "Unfiltered feature-barcode matrices HDF5"  "raw_feature_bc_matrix.h5",
    out path                 analysis                       "Secondary analysis output CSV",
    out h5                   molecule_info                  "Per-molecule read information",
    out cloupe               cloupe                         "Loupe Browser file",
    out csv                  feature_reference              "Feature Reference",
    out csv                  target_panel                   "Target Panel file",
    out csv                  probe_set                      "Probe Set file",
    out csv                  isotype_normalization_factors  "Normalization factors used to normalize AB counts",
    out path                 deconvolution                  "Deconvolution directory",
    out h5                   raw_probe_bc_matrix            "Raw probe barcode matrix",
    out h5                   feature_slice                  "Feature Slice matrix",
    out map<BinnedOutputsCs> binned_outputs                 "Outputs at each bin level",
    out cloupe               cloupe_008um                   "Loupe Browser file (8um bin size)",
    out cloupe               cloupe_custom                  "Loupe Browser file (custom bin size)",
)
{
    call SPACERANGER_PREFLIGHT(
        sample_def                = self.sample_def,
        reference_path            = self.reference_path,
        feature_reference         = self.feature_reference,
        recovered_cells           = null,
        force_cells               = null,
        r1_length                 = self.r1_length,
        r2_length                 = self.r2_length,
        tissue_image_paths        = self.tissue_image_paths,
        dark_images               = self.dark_images,
        dapi_channel_index        = self.dapi_channel_index,
        loupe_alignment_file      = self.loupe_alignment_file,
        gpr_file                  = self.gpr_file,
        hd_layout_file            = self.hd_layout_file,
        cytassist_image_paths     = self.cytassist_image_paths,
        cytassist_tgz_path        = null,
        check_cytassist_sizes     = true,
        slide_serial_capture_area = self.slide_serial_capture_area,
        targeting_method          = self.targeting_method,
        chemistry                 = self.chemistry,
        custom_chemistry_def      = null,
        v1_filtered_fbm           = self.v1_filtered_fbm,
        hd_log_umi_image          = null,
        is_pd                     = false,
        override_id               = self.override_id,
    ) using (
        preflight = true,
    )

    call SPACERANGER_PREFLIGHT_LOCAL(
        sample_def                = self.sample_def,
        reference_path            = self.reference_path,
        feature_reference         = self.feature_reference,
        recovered_cells           = null,
        force_cells               = null,
        r1_length                 = self.r1_length,
        r2_length                 = self.r2_length,
        tissue_image_paths        = self.tissue_image_paths,
        dark_images               = self.dark_images,
        loupe_alignment_file      = self.loupe_alignment_file,
        gpr_file                  = self.gpr_file,
        hd_layout_file            = self.hd_layout_file,
        cytassist_image_paths     = self.cytassist_image_paths,
        slide_serial_capture_area = self.slide_serial_capture_area,
        targeting_method          = self.targeting_method,
        chemistry                 = self.chemistry,
        custom_chemistry_def      = null,
        v1_filtered_fbm           = self.v1_filtered_fbm,
        is_pd                     = false,
    ) using (
        local     = true,
        preflight = true,
    )

    call SPATIAL_RNA_COUNTER_PREP(
        sample_id            = self.sample_id,
        sample_def           = self.sample_def,
        chemistry            = self.chemistry,
        custom_chemistry_def = null,
        r1_length            = self.r1_length,
        r2_length            = self.r2_length,
        is_pd                = false,
        allowed_chems        = [
            "SPATIAL3Pv1",
            "SPATIAL3Pv2",
            "SPATIAL3Pv3",
            "SPATIAL3Pv4",
            "SPATIAL3Pv5",
            "SPATIAL-HD-v1",
        ],
        reference_path       = self.reference_path,
    )

    call _SPATIAL_IMAGING_CS as SPATIAL_IMAGING_CS(
        slide_serial_capture_area = self.slide_serial_capture_area,
        loupe_alignment_file      = self.loupe_alignment_file,
        gpr_file                  = self.gpr_file,
        hd_layout_file            = self.hd_layout_file,
        reorientation_mode        = self.reorientation_mode,
        tissue_image_paths        = self.tissue_image_paths,
        cytassist_image_paths     = self.cytassist_image_paths,
        tissue_image_pixel_size   = self.image_scale,
        dark_images               = self.dark_images,
        dapi_channel_index        = self.dapi_channel_index,
        barcode_whitelist         = SPATIAL_RNA_COUNTER_PREP.barcode_whitelist,
        visium_hd_slide_name      = SPATIAL_RNA_COUNTER_PREP.visium_hd_slide_name,
        image_page_names          = self.image_page_names,
        skip_tissue_detection     = self.skip_tissue_detection,
    )

    call CLOUPE_TILE_IMAGES(
        loupe_alignment_file  = self.loupe_alignment_file,
        tissue_image_paths    = SPATIAL_IMAGING_CS.cloupe_display_image_paths,
        tile_size             = 512,
        skip_stage            = false,
        no_secondary_analysis = false,
    ) using (
        volatile = true,
    )

    call SPATIAL_RNA_COUNTER(
        sample_id                     = self.sample_id,
        sample_def                    = self.sample_def,
        sample_desc                   = self.sample_desc,
        slide_serial_capture_area     = self.slide_serial_capture_area,
        chunks                        = SPATIAL_RNA_COUNTER_PREP.chunks,
        chemistry_defs                = SPATIAL_RNA_COUNTER_PREP.chemistry_defs,
        subsample_rate                = null,
        initial_reads                 = null,
        no_bam                        = self.no_bam,
        no_secondary_analysis         = self.no_secondary_analysis,
        filter_probes                 = self.filter_probes,
        no_target_umi_filter          = true,
        aligner                       = self.aligner,
        is_pd                         = false,
        include_introns               = self.include_introns,
        reference_path                = self.reference_path,
        is_antibody_only              = SPATIAL_RNA_COUNTER_PREP.is_antibody_only,
        recovered_cells               = null,
        force_cells                   = null,
        r1_length                     = self.r1_length,
        r2_length                     = self.r2_length,
        trim_polya_min_score          = self.trim_polya_min_score,
        trim_tso_min_score            = self.trim_tso_min_score,
        min_reads_to_report_bc        = 1000,
        barcodes_under_tissue         = SPATIAL_IMAGING_CS.barcodes_under_tissue,
        alignment_metrics             = SPATIAL_IMAGING_CS.alignment_metrics,
        aligned_fiducials             = SPATIAL_IMAGING_CS.aligned_fiducials,
        tissue_hires_img              = SPATIAL_IMAGING_CS.tissue_hires_image,
        tissue_lowres_img             = SPATIAL_IMAGING_CS.tissue_lowres_image,
        cytassist_image               = SPATIAL_IMAGING_CS.cytassist_image,
        detected_tissue_img           = SPATIAL_IMAGING_CS.detected_tissue_image,
        qc_resampled_cyta_img         = SPATIAL_IMAGING_CS.qc_resampled_cyta_img,
        qc_regist_target_img          = SPATIAL_IMAGING_CS.qc_regist_target_img,
        aligned_tissue_img            = SPATIAL_IMAGING_CS.aligned_tissue_image,
        tissue_positions              = SPATIAL_IMAGING_CS.tissue_positions,
        tissue_transform_json         = null,
        tissue_registration_metrics   = SPATIAL_IMAGING_CS.tissue_registration_metrics,
        image_scale_factors           = SPATIAL_IMAGING_CS.image_scalefactors,
        fraction_under_tissue         = SPATIAL_IMAGING_CS.fraction_under_tissue,
        barcode_fluorescence_intensity = SPATIAL_IMAGING_CS.barcode_fluorescence_intensity,
        feature_reference             = self.feature_reference,
        reorientation_mode            = self.reorientation_mode,
        loupe_alignment_file          = self.loupe_alignment_file,
        cytassist_image_paths         = self.cytassist_image_paths,
        tissue_image_paths            = SPATIAL_IMAGING_CS.cloupe_display_image_paths,
        feature_config                = null,
        v1_filtered_fbm               = self.v1_filtered_fbm,
        fraction_bc_outside_image     = SPATIAL_IMAGING_CS.fraction_bc_outside_image,
        is_visium_hd                  = SPATIAL_IMAGING_CS.is_visium_hd,
        hd_layout_data_json           = SPATIAL_IMAGING_CS.hd_layout_data_json,
        visium_hd_slide_name          = SPATIAL_RNA_COUNTER_PREP.visium_hd_slide_name,
        override_id                   = self.override_id,
        fiducial_positions_list       = SPATIAL_IMAGING_CS.fiducial_positions_list,
        scalefactors                  = SPATIAL_IMAGING_CS.image_scalefactors,
        dark_images                   = self.dark_images,
        dzi_info                      = CLOUPE_TILE_IMAGES.dzi_info,
        dzi_tiles_paths               = CLOUPE_TILE_IMAGES.dzi_tiles_paths,
        image_page_names              = SPATIAL_IMAGING_CS.cloupe_image_page_names,
        custom_bin_size               = self.custom_bin_size,
        scales                        = [
            1,
            4,
            8,
        ],
        tissue_registration_transform = SPATIAL_IMAGING_CS.tissue_transform_json,
        fiducial_transform            = SPATIAL_IMAGING_CS.fiducial_transform,
        registration_target_image     = SPATIAL_IMAGING_CS.registration_target_image,
        umi_registration_outs         = null,
    )

    call CLOUPE_PREPROCESS(
        pipestance_type              = "SPATIAL_RNA_COUNTER_CS",
        sample_id                    = self.sample_id,
        sample_desc                  = self.sample_desc,
        analysis                     = SPATIAL_RNA_COUNTER.analysis,
        filtered_gene_bc_matrices_h5 = SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        metrics_json                 = SPATIAL_RNA_COUNTER.metrics_summary_json,
        aggregation_csv              = null,
        gem_group_index_json         = null,
        image_page_names             = SPATIAL_IMAGING_CS.cloupe_image_page_names,
        tissue_image_paths           = SPATIAL_IMAGING_CS.cloupe_display_image_paths,
        dark_images                  = self.dark_images,
        tissue_positions             = SPATIAL_IMAGING_CS.tissue_positions,
        fiducial_positions_list      = SPATIAL_IMAGING_CS.fiducial_positions_list,
        dzi_info                     = CLOUPE_TILE_IMAGES.dzi_info,
        dzi_tiles_paths              = CLOUPE_TILE_IMAGES.dzi_tiles_paths,
        scale_factors_json           = SPATIAL_IMAGING_CS.image_scalefactors,
        no_secondary_analysis        = false,
        barcode_whitelist            = SPATIAL_RNA_COUNTER_PREP.barcode_whitelist,
        hd_slide_name                = SPATIAL_RNA_COUNTER_PREP.visium_hd_slide_name,
        loupe_map                    = null,
        product_type                 = "sp",
        cells_per_sample             = null,
        cells_per_tag                = null,
        cells_per_protospacer        = null,
        spatial_enrichment           = SPATIAL_RNA_COUNTER.spatial_enrichment,
        spatial_deconvolution_path   = SPATIAL_RNA_COUNTER.deconvolution,
        disable_cloupe               = null,
    )

    call PICK_SPATIAL_COUNTER_OUTS(
        filtered_feature_bc_matrix_h5_in = SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_h5,
        filtered_feature_bc_matrix_mex_in = SPATIAL_RNA_COUNTER.filtered_gene_bc_matrices_mex,
        raw_feature_bc_matrix_h5_in  = SPATIAL_RNA_COUNTER.raw_gene_bc_matrices_h5,
        raw_feature_bc_matrix_mex_in = SPATIAL_RNA_COUNTER.raw_gene_bc_matrices_mex,
        raw_probe_bc_matrix_h5_in    = SPATIAL_RNA_COUNTER.raw_probe_bc_matrix,
        cloupe_files                 = SPATIAL_RNA_COUNTER.binned_outputs.cloupe,
        is_visium_hd                 = SPATIAL_IMAGING_CS.is_visium_hd,
        custom_bin_size              = self.custom_bin_size,
        sd_web_summary               = SPATIAL_RNA_COUNTER.web_summary,
        hd_web_summary               = SPATIAL_RNA_COUNTER.hd_web_summary,
    )

    return (
        possorted_genome_bam          = SPATIAL_RNA_COUNTER.possorted_genome_bam,
        possorted_genome_bai_index    = SPATIAL_RNA_COUNTER.possorted_genome_bai_index,
        possorted_genome_csi_index    = SPATIAL_RNA_COUNTER.possorted_genome_csi_index,
        web_summary                   = PICK_SPATIAL_COUNTER_OUTS.web_summary,
        spatial                       = SPATIAL_RNA_COUNTER.spatial,
        metrics_summary               = SPATIAL_RNA_COUNTER.metrics_summary_csv,
        raw_feature_bc_matrix         = PICK_SPATIAL_COUNTER_OUTS.raw_feature_bc_matrix_mex_out,
        raw_feature_bc_matrix_h5      = PICK_SPATIAL_COUNTER_OUTS.raw_feature_bc_matrix_h5_out,
        filtered_feature_bc_matrix    = PICK_SPATIAL_COUNTER_OUTS.filtered_feature_bc_matrix_mex_out,
        filtered_feature_bc_matrix_h5 = PICK_SPATIAL_COUNTER_OUTS.filtered_feature_bc_matrix_h5_out,
        analysis                      = SPATIAL_RNA_COUNTER.analysis_csv,
        molecule_info                 = SPATIAL_RNA_COUNTER.molecule_info,
        cloupe                        = CLOUPE_PREPROCESS.output_for_cloupe,
        feature_reference             = SPATIAL_RNA_COUNTER.feature_reference,
        target_panel                  = SPATIAL_RNA_COUNTER.target_panel,
        probe_set                     = SPATIAL_RNA_COUNTER.probe_set,
        deconvolution                 = SPATIAL_RNA_COUNTER.deconvolution,
        raw_probe_bc_matrix           = PICK_SPATIAL_COUNTER_OUTS.raw_probe_bc_matrix_h5_out,
        isotype_normalization_factors = SPATIAL_RNA_COUNTER.isotype_normalization_factors,
        feature_slice                 = SPATIAL_RNA_COUNTER.hd_feature_slice,
        binned_outputs                = SPATIAL_RNA_COUNTER.binned_outputs,
        cloupe_008um                  = PICK_SPATIAL_COUNTER_OUTS.cloupe_008um,
        cloupe_custom                 = PICK_SPATIAL_COUNTER_OUTS.cloupe_custom,
    )
}

#
# @include "__V13B23-283_C1.mro"
#

call SPATIAL_RNA_COUNTER_CS(
    sample_id                 = "V13B23-283_C1",
    sample_def                = [
        {
            "fastq_id": null,
            "fastq_mode": "ILMN_BCL2FASTQ",
            "gem_group": null,
            "lanes": null,
            "library_type": "Gene Expression",
            "read_path": "/dcs05/lieber/lcolladotor/visiumStitched_LIBD1070/LS_visiumStitched/raw-data/FASTQ/V13B23-283_C1",
            "sample_indices": ["any"],
            "sample_names": ["2v_LS_SVB"],
            "subsample_rate": null,
            "target_set": null,
            "target_set_name": null,
        },
    ],
    sample_desc               = "",
    slide_serial_capture_area = "V13B23-283-C1",
    loupe_alignment_file      = "/dcs05/lieber/lcolladotor/visiumStitched_LIBD1070/LS_visiumStitched/processed-data/images/loupe/V13B23-283-C1.json",
    gpr_file                  = null,
    hd_layout_file            = null,
    reference_path            = "/dcs04/lieber/lcolladotor/annotationFiles_LIBD001/10x/refdata-gex-GRCh38-2024-A",
    no_bam                    = true,
    no_secondary_analysis     = false,
    filter_probes             = true,
    r1_length                 = null,
    r2_length                 = null,
    targeting_method          = null,
    aligner                   = null,
    chemistry                 = "SPATIAL3Pv1",
    trim_polya_min_score      = 20,
    trim_tso_min_score        = 20,
    feature_reference         = null,
    tissue_image_paths        = ["/dcs05/lieber/lcolladotor/visiumStitched_LIBD1070/LS_visiumStitched/processed-data/images/capture-areas/V13B23-283_C1.tif"],
    dark_images               = 0,
    image_page_names          = null,
    reorientation_mode        = "rotation+mirror",
    cytassist_image_paths     = [],
    dapi_channel_index        = null,
    skip_tissue_detection     = false,
    include_introns           = false,
    custom_bin_size           = null,
    image_scale               = null,
    override_id               = true,
    v1_filtered_fbm           = null,
)
